# Specification: omega-memory/migrations/006_limitations.sql

## Path

`crates/omega-memory/migrations/006_limitations.sql`

## Purpose

Creates the `limitations` table for Omega to track self-detected capability limitations. As an autonomous agent, Omega periodically performs self-audits (via the heartbeat loop or on demand) and identifies gaps in its own capabilities—areas where it lacks knowledge, skills, or constraints. Each limitation is stored with a title, description, proposed resolution plan, and lifecycle status. This enables Omega to maintain awareness of its boundaries and propose improvements for future versions.

This migration was introduced alongside Phase 4 autonomous self-monitoring and heartbeat features.

## Prerequisites

- Migration `001_init.sql` must have been applied (creates the base schema).
- No dependency on other tables -- `limitations` is independent of `conversations`, `messages`, `facts`, and `scheduled_tasks`.

---

## Schema Changes

### CREATE TABLE: `limitations`

```sql
CREATE TABLE IF NOT EXISTS limitations (
    id            TEXT PRIMARY KEY,
    title         TEXT NOT NULL,
    description   TEXT NOT NULL,
    proposed_plan TEXT NOT NULL DEFAULT '',
    status        TEXT NOT NULL DEFAULT 'open',
    created_at    TEXT NOT NULL DEFAULT (datetime('now')),
    resolved_at   TEXT
);
```

### Column Descriptions

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| `id` | `TEXT` | `PRIMARY KEY` | UUID v4 string, generated by `Store::store_limitation()`. |
| `title` | `TEXT` | `NOT NULL` | Brief, case-insensitive unique title for the limitation (e.g., `"Cannot execute arbitrary Python code"`, `"No persistent memory between sessions"`). Used for deduplication. |
| `description` | `TEXT` | `NOT NULL` | Detailed explanation of the limitation—what is blocked, why, and the user impact. |
| `proposed_plan` | `TEXT` | `NOT NULL`, default `''` | Optional solution or workaround plan. Empty string if no plan has been proposed yet. May be updated as strategies are discovered. |
| `status` | `TEXT` | `NOT NULL`, default `'open'` | Lifecycle state of the limitation. See Status Values below. |
| `created_at` | `TEXT` | `NOT NULL`, default `datetime('now')` | When the limitation was first identified. |
| `resolved_at` | `TEXT` | nullable | When the limitation was resolved or closed. Set only when status transitions to `'resolved'`. |

---

### CREATE INDEX: `idx_limitations_title`

```sql
CREATE UNIQUE INDEX IF NOT EXISTS idx_limitations_title ON limitations(title COLLATE NOCASE);
```

| Property | Value |
|----------|-------|
| Columns | `(title)` with `COLLATE NOCASE` |
| Uniqueness | `UNIQUE` — prevents duplicate limitation titles regardless of case. |
| Purpose | Enforce deduplication of limitations by title. Used by `Store::store_limitation()` which attempts INSERT OR IGNORE, returning true only if a new row was created. The case-insensitive collation ensures titles like `"Cannot Execute Code"` and `"cannot execute code"` are treated as the same limitation. |

---

## Status Values

| Status | Meaning | Set By |
|--------|---------|--------|
| `open` | Limitation is active and acknowledged. This is the initial state. | `store_limitation()` (default), when a new limitation is first identified. |
| `resolved` | Limitation has been addressed or is no longer applicable. | `mark_limitation_resolved()` (manual update or after verification). Sets `resolved_at` to current timestamp. |

---

## Migration Tracking

This migration is registered with name `"006_limitations"` in the `_migrations` table. The migration runner in `Store::run_migrations()` checks for this name and skips execution if already applied.

**Migration definitions (compile-time embedded):**
```rust
("006_limitations", include_str!("../migrations/006_limitations.sql"))
```

---

## Application-Level Usage

### `Store::store_limitation()`

Inserts a new limitation or ignores if a limitation with the same title (case-insensitive) already exists.

```rust
pub async fn store_limitation(
    &self,
    title: &str,
    description: &str,
    proposed_plan: &str,
) -> Result<bool, OmegaError>
```

**Parameters:**
- `title`: Brief, unique limitation title.
- `description`: Detailed explanation of the limitation.
- `proposed_plan`: Optional solution plan; pass empty string if none proposed yet.

**Returns:** `true` if a new limitation was inserted, `false` if a limitation with the same title already exists (no-op).

**Called by:** `gateway.rs::handle_message()` Stage 5h, after extracting a `LIMITATION:` marker from the provider response.

### `Store::get_open_limitations()`

Retrieves all open (unresolved) limitations, ordered by creation time.

```rust
pub async fn get_open_limitations(
    &self,
) -> Result<Vec<(String, String, String)>, OmegaError>
```

**Returns:** `(title, description, proposed_plan)` tuples for all limitations with `status = 'open'`.

**Called by:** `gateway.rs::heartbeat_loop()` during self-audit checks, and potentially via bot commands for reporting limitations.

### `Store::mark_limitation_resolved()`

Marks a limitation as resolved by title prefix.

```rust
pub async fn mark_limitation_resolved(&self, title_prefix: &str) -> Result<bool, OmegaError>
```

**Parameters:**
- `title_prefix`: Prefix of the limitation title to resolve (case-insensitive match).

**Returns:** `true` if a limitation was updated, `false` if no match found.

**Side effects:** Sets `resolved_at` to current `datetime('now')` and sets `status` to `'resolved'`.

**Called by:** Bot commands or manual updates when a limitation is addressed.

---

## Relationship to Other Migrations

| Migration | Name | What It Creates |
|-----------|------|----------------|
| `001_init.sql` | `001_init` | `conversations`, `messages`, `facts` (original) |
| `002_audit_log.sql` | `002_audit_log` | `audit_log` |
| `003_memory_enhancement.sql` | `003_memory_enhancement` | ALTER `conversations` (+3 cols, +1 idx), DROP+CREATE `facts` |
| `004_fts5_recall.sql` | `004_fts5_recall` | `messages_fts` virtual table, 3 sync triggers, backfill |
| `005_scheduled_tasks.sql` | `005_scheduled_tasks` | `scheduled_tasks` table, 2 indexes |
| **`006_limitations.sql`** | **`006_limitations`** | **`limitations` table, 1 unique index** |

---

## Idempotency

- `CREATE TABLE IF NOT EXISTS` is idempotent.
- `CREATE UNIQUE INDEX IF NOT EXISTS` is idempotent.
- The entire migration file is idempotent and can safely be re-run, though the migration tracker prevents re-execution.

---

## Performance Considerations

- **Unique index on (title) with COLLATE NOCASE:** Efficiently prevents duplicate limitations while allowing flexible title lookups. The case-insensitive collation ensures semantic deduplication (e.g., `"Cannot execute code"` and `"cannot execute code"` are treated as the same).
- **No triggers:** Unlike the FTS5 migration, this table has no triggers. All state transitions are handled by explicit store method calls.
- **Lightweight storage:** The table stores only metadata about limitations, not their full history. If historical tracking is needed in the future, an audit table can be introduced.
- **Linear scans for open limitations:** Since `get_open_limitations()` filters by `status = 'open'` without additional criteria, a full table scan is typical. For large installations with many resolved limitations, an index on `(status, created_at)` could be added in a future migration.
