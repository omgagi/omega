# Specification: src/gateway.rs

## File Path
`/Users/isudoajl/ownCloud/Projects/omega/src/gateway.rs`

## Purpose
Gateway is the central event loop orchestrator that connects messaging channels, memory persistence, and AI providers. It implements the complete message processing pipeline with authentication, sanitization, context building, provider delegation, audit logging, and graceful shutdown.

## Architecture Overview

### Core Responsibility
The gateway manages the asynchronous event loop that processes incoming messages through a deterministic pipeline:

```
Message → Auth → Sanitize → Command Check → Typing → Context → MCP Trigger Match →
Classify & Route (always, model selection) → Provider (MCP settings write → CLI → MCP cleanup) → Memory Store → Audit Log → Send
```

The gateway runs continuously, listening for messages from registered channels via an mpsc channel, and spawns a background task for periodic conversation summarization.

## Data Structures

### Gateway Struct
```rust
pub struct Gateway {
    provider: Arc<dyn Provider>,              // AI backend (Claude Code, Anthropic, etc.)
    channels: HashMap<String, Arc<dyn Channel>>,  // Messaging platforms (Telegram, WhatsApp)
    memory: Store,                             // SQLite conversation/fact storage
    audit: AuditLogger,                        // Event audit trail
    auth_config: AuthConfig,                   // Authentication rules
    channel_config: ChannelConfig,             // Per-channel configuration
    heartbeat_config: HeartbeatConfig,         // Periodic AI check-in settings
    scheduler_config: SchedulerConfig,         // Scheduled task delivery settings
    prompts: Prompts,                          // Externalized prompts & welcome messages
    sandbox_mode: String,                      // Display name of active sandbox mode
    sandbox_prompt: Option<String>,            // Sandbox constraint text for system prompt
    model_fast: String,                        // Model for DIRECT/simple messages (e.g., "claude-sonnet-4-6")
    model_complex: String,                     // Model for multi-step/complex messages (e.g., "claude-opus-4-6")
    uptime: Instant,                           // Server start time
    active_senders: Mutex<HashMap<String, Vec<IncomingMessage>>>,  // Per-sender message buffer for non-blocking dispatch
    heartbeat_interval: Arc<AtomicU64>,        // Dynamic heartbeat interval (minutes), updated via HEARTBEAT_INTERVAL: marker
}
```

**Fields:**
- `provider`: Shared reference to the configured AI provider. Must implement the `Provider` trait.
- `channels`: Map of channel names to channel implementations. Each channel independently listens for messages.
- `memory`: Shared SQLite-backed store for conversation history, facts, and metadata.
- `audit`: Logger that records all interactions for security and debugging.
- `auth_config`: Global authentication policy (enabled flag, deny message).
- `channel_config`: Per-channel settings (Telegram allowed_users list).
- `heartbeat_config`: Periodic heartbeat check-in configuration (interval, active hours, channel, reply target).
- `scheduler_config`: Scheduled task delivery configuration (enabled flag, poll interval).
- `prompts`: Externalized prompts and welcome messages, loaded from `~/.omega/SYSTEM_PROMPT.md` and `~/.omega/WELCOME.toml` at startup. Falls back to hardcoded defaults if files are missing.
- `sandbox_mode`: Display name of the active sandbox mode (e.g., `"sandbox"`, `"rx"`, `"rwx"`). Used in startup logging and passed to `CommandContext` for `/status`.
- `sandbox_prompt`: Optional sandbox constraint text injected into the system prompt before context building. Generated by `SandboxMode::prompt_constraint()`. When `Some`, prepended to the system prompt to instruct the provider about filesystem restrictions. When `None` (rwx mode), no constraint is added.
- `model_fast`: Model identifier used for DIRECT/simple messages (e.g., `"claude-sonnet-4-6"`). Set from `ClaudeCodeConfig.model` at startup. Injected into `context.model` by `classify_and_route()` for direct-path messages.
- `model_complex`: Model identifier used for multi-step/complex messages (e.g., `"claude-opus-4-6"`). Set from `ClaudeCodeConfig.model_complex` at startup. Injected into `context.model` by `classify_and_route()` for step-based execution.
- `uptime`: Tracks server start time for uptime calculations in commands.
- `active_senders`: A `Mutex<HashMap<String, Vec<IncomingMessage>>>` that tracks which senders currently have an active provider call in flight. When a new message arrives for a sender that is already being processed, the message is buffered here. After the active call completes, buffered messages are dispatched in order.
- `heartbeat_interval`: An `Arc<AtomicU64>` holding the current heartbeat interval in minutes. Initialized from `heartbeat_config.interval_minutes` and shared with the heartbeat loop and scheduler loop. Updated at runtime via `HEARTBEAT_INTERVAL:` markers. Resets to config value on restart.

## Functions

### Public Methods

#### `new(provider, channels, memory, auth_config, channel_config, heartbeat_config, scheduler_config, prompts, sandbox_mode, sandbox_prompt, model_fast, model_complex) -> Self`
**Purpose:** Construct a new gateway instance.

**Parameters:**
- `provider: Arc<dyn Provider>` - The AI backend (typically Claude Code CLI provider).
- `channels: HashMap<String, Arc<dyn Channel>>` - Map of initialized channel implementations.
- `memory: Store` - SQLite store initialized with database pool.
- `auth_config: AuthConfig` - Authentication configuration.
- `channel_config: ChannelConfig` - Per-channel configuration.
- `heartbeat_config: HeartbeatConfig` - Heartbeat check-in configuration.
- `scheduler_config: SchedulerConfig` - Scheduled task delivery configuration.
- `prompts: Prompts` - Externalized prompts and welcome messages (loaded from `~/.omega/` files or defaults).
- `sandbox_mode: String` - Display name of the active sandbox mode (e.g., `"sandbox"`, `"rx"`, `"rwx"`).
- `sandbox_prompt: Option<String>` - Optional sandbox constraint text for system prompt injection.
- `model_fast: String` - Model identifier for DIRECT/simple messages (from `ClaudeCodeConfig.model`).
- `model_complex: String` - Model identifier for multi-step/complex messages (from `ClaudeCodeConfig.model_complex`).

**Returns:** New `Gateway` instance.

**Logic:**
- Creates an `AuditLogger` from the memory pool.
- Captures current time as `uptime`.
- Stores all parameters as instance fields.

**Error Handling:** None (infallible). Has `#[allow(clippy::too_many_arguments)]` attribute.

#### `async fn run(self: Arc<Self>) -> anyhow::Result<()>`
**Purpose:** Start the gateway event loop and run until shutdown signal.

**Parameters:** None (takes `self: Arc<Self>` instead of `&mut self`).

**Returns:** `anyhow::Result<()>` (Ok on graceful shutdown, Err on critical failure).

**Note:** The method takes `self: Arc<Self>` to allow the gateway to be shared across spawned tasks for non-blocking message dispatch. The gateway is wrapped in `Arc::new()` in `main.rs`.

**Logic:**
1. Log gateway initialization with provider name, channel names, auth status, and sandbox mode.
2. Create an mpsc channel with capacity 256 for incoming messages.
3. For each registered channel:
   - Call `channel.start()` to get a receiver for that channel's messages.
   - Spawn a background task that forwards all messages from the channel receiver to the gateway's main mpsc channel.
   - Log successful channel start.
4. Drop the sender to signal EOF when all channels close.
5. Spawn a background summarization task via `tokio::spawn(background_summarizer())`.
6. If `scheduler_config.enabled`, spawn `scheduler_loop()` via `tokio::spawn()`. Store handle as `Option<JoinHandle<()>>`.
7. If `heartbeat_config.enabled`, spawn `heartbeat_loop()` via `tokio::spawn()`. Store handle as `Option<JoinHandle<()>>`.
8. Enter the main event loop using `tokio::select!`:
   - Wait for incoming messages via `rx.recv()` and call `dispatch_message()`.
   - Wait for Ctrl+C signal via `tokio::signal::ctrl_c()`.
   - On shutdown signal, break from loop.
9. Call `shutdown(bg_handle, sched_handle, hb_handle)` for graceful cleanup.
10. Return Ok(()).

**Async Patterns:**
- Uses `tokio::spawn` to run channel listeners concurrently.
- Uses `tokio::select!` for the main event loop to handle both messages and shutdown signals.
- Scheduler and heartbeat loops are conditionally spawned based on config.
- All channel and provider operations are awaited.

**Error Handling:**
- If `channel.start()` fails, wraps error in anyhow and returns immediately.
- Channel listener tasks suppress errors silently (logs info if gateway receiver drops).

#### `async fn background_summarizer(store: Store, provider: Arc<dyn Provider>, summarize_prompt: String, facts_prompt: String)`
**Purpose:** Periodically find and summarize idle conversations (infinite background task).

**Parameters:**
- `store: Store` - Shared memory store.
- `provider: Arc<dyn Provider>` - Shared provider reference.
- `summarize_prompt: String` - Prompt template for conversation summarization (from `Prompts.summarize`).
- `facts_prompt: String` - Prompt template for facts extraction (from `Prompts.facts`).

**Returns:** Never returns (infinite loop).

**Logic:**
1. Loop forever with 60-second sleep between iterations.
2. Call `store.find_idle_conversations()` to find conversations inactive for a threshold period.
3. For each idle conversation:
   - Call `summarize_conversation()` to summarize and close it.
   - Log errors but continue processing other conversations.
4. Log errors from `find_idle_conversations()` but continue the loop.

**Async Patterns:**
- Uses `tokio::time::sleep()` for periodic ticking.
- All storage and provider operations are awaited.

**Error Handling:**
- Errors are logged with `error!()` but do not stop the task.
- Task runs indefinitely regardless of errors.

#### `async fn scheduler_loop(store: Store, channels: HashMap<String, Arc<dyn Channel>>, poll_secs: u64)`
**Purpose:** Background task that periodically checks for due scheduled tasks and delivers them via the appropriate channel.

**Parameters:**
- `store: Store` - Shared memory store for task queries.
- `channels: HashMap<String, Arc<dyn Channel>>` - Map of channel implementations for delivery.
- `poll_secs: u64` - Polling interval in seconds (from `SchedulerConfig.poll_interval_secs`).

**Returns:** Never returns (infinite loop).

**Logic:**
1. Loop forever with `poll_secs`-second sleep between iterations.
2. Call `store.get_due_tasks()` to find tasks where `status = 'pending'` and `due_at <= now`.
3. For each due task `(id, channel_name, reply_target, description, repeat)`:
   - Build an `OutgoingMessage` with text `"Reminder: {description}"` and `reply_target`.
   - Look up the channel by `channel_name` in the channels map.
   - If channel not found, log warning and skip.
   - Send the message via `channel.send()`.
   - If send fails, log error and skip to next task.
   - Call `store.complete_task(id, repeat)` to mark task as delivered (one-shot) or advance `due_at` (recurring).
   - Log success.
4. Log errors from `get_due_tasks()` but continue the loop.

**Async Patterns:**
- Uses `tokio::time::sleep()` for periodic ticking.
- All storage and channel operations are awaited.

**Error Handling:**
- Channel send errors are logged and the task is skipped (not marked complete).
- Task completion errors are logged but do not stop the loop.
- `get_due_tasks()` errors are logged but do not stop the loop.

#### `async fn heartbeat_loop(provider: Arc<dyn Provider>, channels: HashMap<String, Arc<dyn Channel>>, config: HeartbeatConfig, heartbeat_checklist_prompt: String, memory: Store, interval: Arc<AtomicU64>)`
**Purpose:** Background task that periodically invokes the AI provider for a context-aware health check-in. Skips the API call entirely when no checklist is configured. If the provider reports an issue, the alert is delivered via a configured channel. If everything is fine (response contains `HEARTBEAT_OK`), the response is suppressed.

**Parameters:**
- `provider: Arc<dyn Provider>` - Shared provider reference for the check-in call.
- `channels: HashMap<String, Arc<dyn Channel>>` - Map of channel implementations for alert delivery.
- `config: HeartbeatConfig` - Heartbeat configuration (interval, active hours, channel, reply target).
- `heartbeat_checklist_prompt: String` - Prompt template with `{checklist}` placeholder (from `Prompts.heartbeat_checklist`).
- `memory: Store` - Shared memory store for enriching heartbeat context with user facts and recent summaries.
- `interval: Arc<AtomicU64>` - Shared atomic holding the current interval in minutes. Read on each iteration. Updated by `process_markers()` or `scheduler_loop` when a `HEARTBEAT_INTERVAL:` marker is processed.

**Returns:** Never returns (infinite loop).

**Logic:**
1. Loop forever, reading the interval from the shared `AtomicU64` on each iteration (dynamic, not fixed at startup).
2. Check active hours:
   - If both `active_start` and `active_end` are non-empty, call `is_within_active_hours()`.
   - If outside active hours, log info and skip this iteration.
3. Read checklist from `~/.omega/HEARTBEAT.md` via `read_heartbeat_file()`.
4. **Skip when no checklist**: If `read_heartbeat_file()` returns `None`, log info and skip this iteration entirely (no API call).
5. Build prompt from `heartbeat_checklist_prompt` with `{checklist}` replaced by the file content.
6. **Context enrichment**: Enrich the prompt with memory data:
   - Call `memory.get_all_facts()` — if non-empty, append "Known about the user:" followed by key-value pairs.
   - Call `memory.get_all_recent_summaries(3)` — if non-empty, append "Recent activity:" followed by timestamped summaries.
7. Call `provider.complete()` with the enriched prompt context.
8. On success:
   - Strip markdown formatting characters (`*`, `` ` ``) from the response before checking for `HEARTBEAT_OK`.
   - If cleaned response contains `HEARTBEAT_OK`, log info and suppress (no message sent).
   - Otherwise, send the response as an alert via `config.channel` to `config.reply_target`.
   - If channel not found, log warning.
9. On provider error, log error.

**Async Patterns:**
- Uses `tokio::time::sleep()` for periodic ticking.
- Provider and channel operations are awaited.

**Error Handling:**
- Provider errors are logged but do not stop the loop.
- Channel send errors are logged but do not stop the loop.
- Missing channel is logged as warning.

#### `async fn summarize_conversation(store: &Store, provider: &Arc<dyn Provider>, conversation_id: &str, summarize_prompt: &str, facts_prompt_template: &str) -> Result<(), anyhow::Error>`
**Purpose:** Summarize a conversation, extract user facts, and close it.

**Parameters:**
- `store: &Store` - Reference to the memory store.
- `provider: &Arc<dyn Provider>` - Reference to the AI provider.
- `conversation_id: &str` - ID of the conversation to summarize.
- `summarize_prompt: &str` - Prompt for conversation summarization (from `Prompts.summarize`).
- `facts_prompt_template: &str` - Prompt for facts extraction (from `Prompts.facts`).

**Returns:** `Result<(), anyhow::Error>`.

**Logic:**
1. Fetch all messages from the conversation via `store.get_conversation_messages()`.
2. If empty, close the conversation with "(empty conversation)" summary and return Ok.
3. Build a plain-text transcript by iterating messages and formatting as "User: ..." or "Assistant: ...".
4. **Summarization step:**
   - Create prompt by concatenating `summarize_prompt` + "\n\n" + transcript.
   - Call `provider.complete(Context::new(prompt))`.
   - On success, use the response text as summary.
   - On failure, use fallback: "({count} messages, summary unavailable)".
5. **Facts extraction step:**
   - Create prompt by concatenating `facts_prompt_template` + "\n\n" + transcript.
   - Call `provider.complete(Context::new(prompt))`.
   - Parse response line by line as "key: value" pairs.
   - For each valid pair (non-empty key and value), validate via `is_valid_fact(key, value)` before storing.
   - `is_valid_fact()` rejects: keys >50 chars, values >200 chars, numeric-only keys, values starting with `$`, pipe-delimited table rows (2+ pipes), and pure numeric values (price patterns).
   - If response is "none", skip fact storage.
6. Query the database directly via `sqlx::query_as()` to get the `sender_id` from the conversations table.
7. Call `store.close_conversation(conversation_id, summary)` to mark conversation as closed and store summary.
8. Log success.
9. Return Ok(()).

**Async Patterns:**
- Uses `provider.complete()` twice in sequence (summarization, then facts).
- Uses `sqlx::query_as()` directly for database queries.
- All operations are awaited.

**Error Handling:**
- Early return on `get_conversation_messages()` failure.
- Summarization failure falls back to message count.
- Facts extraction errors are caught with `if let Ok()` and skipped.
- Database query errors are suppressed via `.ok().flatten()`.
- Returns top-level error on `close_conversation()` failure.

#### `async fn shutdown(&self, bg_handle: &JoinHandle<()>, sched_handle: &Option<JoinHandle<()>>, hb_handle: &Option<JoinHandle<()>>)`
**Purpose:** Gracefully shut down the gateway.

**Parameters:**
- `bg_handle: &tokio::task::JoinHandle<()>` - Handle to the background summarizer task.
- `sched_handle: &Option<tokio::task::JoinHandle<()>>` - Optional handle to the scheduler loop task.
- `hb_handle: &Option<tokio::task::JoinHandle<()>>` - Optional handle to the heartbeat loop task.

**Returns:** None (void).

**Logic:**
1. Log "Shutting down...".
2. Abort the background summarizer task via `bg_handle.abort()`.
3. If `sched_handle` is `Some`, abort the scheduler task.
4. If `hb_handle` is `Some`, abort the heartbeat task.
5. Find all active conversations via `store.find_all_active_conversations()`.
6. For each active conversation, call `summarize_conversation()` to summarize before closing.
7. Log warnings for summarization errors but continue.
8. For each channel, call `channel.stop()` to cleanly shut down the channel.
9. Log warnings for channel stop errors but continue.
10. Log "Shutdown complete.".

**Error Handling:**
- Errors are logged with `warn!()` but do not stop the shutdown process.
- All channels are stopped regardless of individual failures.

#### `async fn dispatch_message(self: &Arc<Self>, incoming: IncomingMessage)`
**Purpose:** Non-blocking message dispatcher that buffers messages when a sender is already being processed.

**Parameters:**
- `incoming: IncomingMessage` - The message to dispatch.

**Returns:** None (void).

**Logic:**
1. Acquire lock on `self.active_senders`.
2. Check if the sender (`incoming.sender_id`) already has an active provider call in flight:
   - **If busy**: Append the message to the sender's buffer. Send a "Got it, I'll get to this next." acknowledgment to the user. Release the lock and return.
   - **If not busy**: Insert an empty buffer for the sender (marking them as active). Release the lock.
3. Clone `Arc<Self>` and the incoming message.
4. Spawn a `tokio::spawn` task that:
   a. Calls `self.handle_message(incoming)` for the current message.
   b. After completion, enters a loop:
      - Acquire lock on `active_senders`.
      - Pop the next buffered message for this sender.
      - If no more buffered messages, remove the sender from `active_senders` and break.
      - Release lock and call `self.handle_message(buffered_msg)`.
   c. This ensures all buffered messages are processed in order.

**Concurrency Model:**
- Messages for different senders are processed concurrently via `tokio::spawn`.
- Messages for the same sender are serialized: only one provider call per sender at a time.
- The `Mutex` is only held briefly to check/update the buffer, never across async operations.

#### `async fn handle_message(&self, incoming: IncomingMessage)`
**Purpose:** Process a single incoming message through the complete pipeline.

**Parameters:**
- `incoming: IncomingMessage` - The message to process.

**Returns:** None (void, logging errors).

**Pipeline Stages:**

**Stage 1: Auth Check (Lines 262-292)**
- If auth is enabled, call `check_auth()`.
- If denied, log warning, audit the denial, send deny message, and return.
- Audit status: `AuditStatus::Denied`.
- Does not process message further.

**Stage 2: Input Sanitization (Lines 294-305)**
- Call `sanitize::sanitize(&incoming.text)`.
- If modified, log warning with sanitization warnings.
- Clone the incoming message and replace its text with sanitized version.

**Stage 2a: Inbox Image Save**
- If `incoming.attachments` is non-empty:
  - Call `ensure_inbox_dir(data_dir)` to create `{data_dir}/workspace/inbox/` if it does not exist.
  - Call `save_attachments_to_inbox(&inbox_dir, &incoming.attachments)` to save Image-type attachments to disk.
  - For each saved image path, prepend `[Attached image: /full/path.jpg]` to `clean_incoming.text`.
  - Store the returned `Vec<PathBuf>` as `inbox_images` for later cleanup.

**Stage 2b: Welcome Check (First-Time Users)**
- If the sender has no `welcomed` fact (first-time user):
  - Detect language from the incoming message text.
  - Send the localized welcome message from `self.prompts.welcome`.
  - Store `welcomed = "true"` and `preferred_language` facts.
  - Log the welcome event.
  - **Does not return** — the first message falls through to normal processing (command dispatch, context building, provider call, etc.).

**Stage 3: Command Dispatch (Lines 307-320)**
- Call `commands::Command::parse()` to check if input is a bot command.
- If command detected:
  - Call `commands::handle()` to process the command.
  - Send response text.
  - Return (skip provider call).
- Examples: `/uptime`, `/help`, `/status`.

**Stage 3b: Platform Formatting Hint**
- After command dispatch, inject a platform-specific formatting hint into the system prompt:
  - **WhatsApp**: "Platform: WhatsApp. Avoid markdown tables and headers — use bold (*text*) and bullet lists instead."
  - **Telegram**: "Platform: Telegram. Markdown is supported (bold, italic, code blocks)."
  - Other channels: no hint injected.
- This hint is appended to the system prompt before context building.

**Stage 3c: Group Chat Rules Injection**
- If `incoming.is_group` is `true`, append group-specific rules to the system prompt:
  - Only respond when directly mentioned by name, asked a question, or adding genuine value.
  - Do not leak personal facts from private conversations.
  - If the message does not warrant a response, reply with exactly `SILENT`.

**Stage 4: Typing Indicator (Lines 322-342)**
- Get the channel for the incoming message.
- If channel exists and incoming has a `reply_target`, spawn a repeating task:
  - Send initial typing action immediately.
  - Every 5 seconds, resend typing action.
  - Abort if channel send fails.
- Store handle for later abort.

**Stage 4b: Project Instruction Injection**
- Calls `self.memory.get_fact(&incoming.sender_id, "active_project")` to check for an active project.
- If an active project is found, calls `omega_skills::get_project_instructions(&projects, &project_name)` using the hot-reloaded project list.
- If instructions are found, prepends them to the base system prompt with a `---` separator.
- The enriched system prompt is passed to `memory.build_context()`.

**Stage 4c: Heartbeat Awareness**
- After project instruction injection, calls `read_heartbeat_file()`.
- If a heartbeat checklist exists, appends its contents to the system prompt under a "Current heartbeat checklist" header.
- This gives the provider awareness of what items are already being monitored, enabling it to avoid duplicates and to confirm removals.

**Stage 4d: Sandbox Prompt Injection**
- If `self.sandbox_prompt` is `Some(constraint)`, prepends the sandbox constraint text to the system prompt.
- This injects mode-specific instructions (e.g., "You are running in SANDBOX mode. Only operate within the workspace directory..." for sandbox mode, or "You are running in READ-ONLY mode..." for rx mode).
- In `rwx` mode, `sandbox_prompt` is `None` and no constraint is injected.

**Stage 5: Build Context from Memory (Lines 344-356)**
- Compose the base system prompt from all three prompt sections: `format!("{}\n\n{}\n\n{}", self.prompts.identity, self.prompts.soul, self.prompts.system)`.
- Call `self.memory.build_context(&clean_incoming, &composed_prompt)` to build enriched context (using the potentially project-enriched system prompt).
- This includes recent conversation history, relevant facts, and system prompt.
- If error, abort typing task, send error message, and return.

**Stage 5b: MCP Trigger Matching**
- Call `omega_skills::match_skill_triggers(&self.skills, &clean_incoming.text)` to check if the message matches any skill triggers.
- If matched, populate `context.mcp_servers` with the declared MCP servers from matching skills.
- The provider will use these to write temporary `.claude/settings.local.json` and add `mcp__<name>__*` to `--allowedTools`.

**Stage 6: Get Response from Provider (async with delayed, localized status updates)**
- Resolve the user's `preferred_language` fact from memory (defaults to English).
- Get localized status messages via `status_messages(lang)`.
- Spawn `provider.complete(&context)` as a background task via `tokio::spawn`.
- Spawn a delayed status updater task: sends a localized first nudge after 15 seconds, then localized "Still working..." every 120 seconds. If the provider responds within 15 seconds, the updater is aborted and the user sees no extra messages.
- Wait for the provider result; abort the status updater when the result arrives.
- Map provider errors to user-friendly messages via `friendly_provider_error()`:
  - On timeout -> "I took too long to respond. Please try again..."
  - On other errors -> "Something went wrong. Please try again."
  - On JoinError (task panic) -> "Something went wrong. Please try again."
- On success, set `reply_target` from incoming message.
- On error:
  - Abort typing task.
  - Audit the error with status `AuditStatus::Error`.
  - Send friendly error message.
  - Return.

**Stage 5a: SILENT Response Suppression (Group Chats)**
- After receiving the provider response and aborting the typing indicator:
- If `incoming.is_group` is `true` AND `response.text.trim()` equals `"SILENT"`:
  - Log info about the suppression.
  - Return immediately (skip storage, audit, and sending).
  - This prevents the bot from sending empty or unwanted responses in group chats.

**Stage 5: Classify and Route (Model Selection)**
- After SILENT suppression check:
- Call `self.classify_and_route()` unconditionally (no word-count gate). This sends a classification prompt enriched with lightweight context (active project name, last 3 history messages truncated to 80 chars, available skill names) to the provider (no system prompt, no MCP servers) with `ctx.model = Some(self.model_fast.clone())` (classification always uses the fast model).
  - The classification response is parsed by `parse_plan_response()`:
    - If the response contains "DIRECT" (any case) → returns `None`.
    - If the response contains only a single step → returns `None`.
    - If the response contains a multi-step numbered list → returns `Some(steps)`.
    - If the response is unparseable → returns `None`.
  - If `None` is returned (DIRECT path): set `context.model = Some(self.model_fast.clone())` and fall through to the normal single provider call.
  - If `Some(steps)` is returned (Steps path): set `context.model = Some(self.model_complex.clone())`.
    - Call `self.execute_steps(incoming, original_task, context, steps, inbox_images)` for autonomous multi-step execution.
    - `execute_steps()` announces the plan to the user, executes each step in a fresh provider call with accumulated context (inheriting `step_ctx.model = context.model.clone()`), retries failed steps up to 3 times, calls `self.process_markers()` on each step result to extract all markers (SCHEDULE, LIMITATION, SELF_HEAL, etc.), sends progress messages after each step, audits the exchange, sends a final summary, and cleans up inbox images.
    - Return (skip normal provider call).

**Stage 5: Process Markers**
- After SILENT suppression check:
- Call `self.process_markers(&incoming, &mut response.text)` — a unified method that extracts and processes all markers from the provider response. This same method is called on each step result in `execute_steps()`, ensuring markers work in both direct and multi-step paths.
- Markers processed in order: SCHEDULE, SCHEDULE_ACTION, PROJECT_ACTIVATE/DEACTIVATE, WHATSAPP_QR, LANG_SWITCH, HEARTBEAT_ADD/REMOVE/INTERVAL, LIMITATION, SELF_HEAL, SELF_HEAL_RESOLVED.
- Each marker is stripped from the response text after processing.

**Stage 6: Store Exchange in Memory (Lines 579-582)**
- Call `self.memory.store_exchange(&incoming, &response)` to save the exchange.
- Log error if storage fails but continue.

**Stage 7: Audit Log (Lines 584-599)**
- Log the successful exchange via `self.audit.log()`.
- Include all metadata: provider, model, processing time.
- Status: `AuditStatus::Ok`.

**Stage 8: Send Response (Lines 601-608)**
- Get the channel for the incoming message.
- Call `channel.send(response)` to deliver the response.
- Log error if channel send fails.

**Stage 8b: Send New Workspace Images**
- After sending the text response, compute a diff of workspace images (before vs. after the provider call).
- For each new image file (`.png`, `.jpg`, `.jpeg`, `.gif`, `.webp`) found in the top-level workspace directory:
  - Read the file bytes via `std::fs::read()`.
  - Call `channel.send_photo(target, &bytes, filename)` to deliver the image.
  - Delete the file after sending (cleanup).
  - Log with `tracing`: `info!` on success, `warn!` on failure.
- Uses `snapshot_workspace_images()` to collect top-level image files before and after the provider call, then computes the set difference.

**Stage 9: Cleanup Inbox Images**
- Call `cleanup_inbox_images(&inbox_images)` to remove temporary inbox files that were saved in Stage 2a.
- Each file is removed individually; errors are logged at warn level but do not stop the cleanup.

**Async Patterns:**
- All stages are awaited sequentially.
- Typing task runs concurrently via `tokio::spawn()`.
- Task is aborted early if error occurs before response.

**Error Handling:**
- Auth failure: deny message sent, audit logged, early return.
- Sanitization warnings: logged but processing continues.
- Context build failure: error message sent, early return.
- Provider error: error message sent, audit logged, early return.
- Memory storage failure: logged but does not stop response delivery.
- Channel send failure: logged but pipeline completes.

#### `fn check_auth(&self, incoming: &IncomingMessage) -> Option<String>`
**Purpose:** Verify if a message sender is authorized.

**Parameters:**
- `incoming: &IncomingMessage` - The incoming message to check.

**Returns:** `Option<String>` where `None` = allowed, `Some(reason)` = denied.

**Logic:**
1. Match on `incoming.channel`:
   - **"telegram"**:
     - Get `allowed_users` list from `channel_config.telegram`.
     - If list is empty, allow all (returns `None`). Used for testing.
     - If list exists:
       - Parse `incoming.sender_id` as i64 (default to -1 on parse error).
       - If sender_id is in allowed_users, return `None`.
       - Otherwise, return `Some("telegram user X not in allowed_users")`.
     - If telegram config not set, return `Some("telegram channel not configured")`.
   - **Other channels**:
     - Return `Some("unknown channel: {name}")`.

**Error Handling:**
- Parsing sender_id as i64 uses `unwrap_or(-1)` (will never match valid user, causing denial).
- No panics.

#### `async fn send_text(&self, incoming: &IncomingMessage, text: &str)`
**Purpose:** Send a plain text response message.

**Parameters:**
- `incoming: &IncomingMessage` - The original incoming message (used for channel and reply target).
- `text: &str` - The text to send.

**Returns:** None (void).

**Logic:**
1. Create an `OutgoingMessage` with:
   - `text: text.to_string()`.
   - `metadata: MessageMetadata::default()`.
   - `reply_target: incoming.reply_target.clone()`.
2. Get the channel for `incoming.channel`.
3. Call `channel.send(msg)`.
4. Log error if send fails.

**Error Handling:**
- Send errors are logged but do not return an error code.

#### `async fn classify_and_route(&self, message: &str, active_project: Option<&str>, recent_history: &[ContextEntry], skill_names: &[&str]) -> Option<Vec<String>>`
**Purpose:** Send a context-enriched classification call to the provider to determine if the message requires multi-step execution. Always runs (no word-count gate). Uses the fast model for classification.

**Parameters:**
- `message: &str` - The user's original message text.
- `active_project: Option<&str>` - The user's currently active project (if any).
- `recent_history: &[ContextEntry]` - Conversation history entries (last 3 used).
- `skill_names: &[&str]` - Names of available skills.

**Returns:** `Option<Vec<String>>` — `Some(steps)` if the classifier identifies a multi-step task, `None` if the response is "DIRECT", single-step, or on error.

**Logic:**
1. Call `build_classification_context()` to produce a lightweight context block (~90 tokens) from the active project, last 3 history messages (truncated to 80 chars each), and skill names. Empty inputs produce an empty block (identical to previous behavior).
2. Build the classification prompt with the context block injected between the instructions and the user's request.
3. Set `ctx.model = Some(self.model_fast.clone())` so classification uses the fast model.
4. Call `provider.complete()` with this minimal context (no system prompt, no MCP servers).
5. On success, pass the response text to `parse_plan_response()`.
6. On error, log the error and return `None` (falls through to normal single provider call).

#### `fn build_classification_context(active_project: Option<&str>, recent_history: &[ContextEntry], skill_names: &[&str]) -> String`
**Purpose:** Build a lightweight context string for the classification prompt. Pure function, no async.

**Parameters:**
- `active_project: Option<&str>` - Active project name (if any).
- `recent_history: &[ContextEntry]` - Conversation history (last 3 entries used, each truncated to 80 chars).
- `skill_names: &[&str]` - Available skill names.

**Returns:** A context string with sections separated by newlines. Empty sections are omitted. Returns empty string when all inputs are empty.

#### `async fn execute_steps(&self, incoming: &IncomingMessage, original_task: &str, context: &Context, steps: Vec<String>, inbox_images: Vec<PathBuf>)`
**Purpose:** Execute a multi-step plan autonomously, reporting progress to the user after each step.

**Parameters:**
- `incoming: &IncomingMessage` - The original incoming message (used for channel, sender, and reply target).
- `original_task: &str` - The user's original message text (used for context in step execution).
- `context: &Context` - The enriched context (system prompt, history, facts).
- `steps: Vec<String>` - The list of step descriptions to execute.
- `inbox_images: Vec<PathBuf>` - Temporary inbox image files to clean up after execution.

**Returns:** None (void).

**Logic:**
1. Announce the plan to the user (list of steps).
2. For each step:
   - Build a step context with `step_ctx.model = context.model.clone()` (inherits model from the parent context, ensuring all steps use the complex model).
   - Execute the step by calling `provider.complete()` with the step description and accumulated context.
   - On failure, retry up to 3 times.
   - If all retries fail, send an error message and continue to next step.
   - On success, call `self.process_markers()` on the step result to extract all markers (SCHEDULE, LIMITATION, SELF_HEAL, etc.).
   - Send a progress message (e.g., "✓ Step (1/N)").
   - Audit the step exchange.
3. After all steps complete, send a final summary message to the user.
4. Clean up inbox images via `cleanup_inbox_images()`.

**Error Handling:**
- Per-step failures are retried up to 3 times before continuing to the next step.
- Provider errors are logged and a user-friendly error message is sent.

#### `async fn process_markers(&self, incoming: &IncomingMessage, text: &mut String)`
**Purpose:** Extract and process all markers from a provider response text. Unified method called by both `handle_message` (direct path) and `execute_steps` (multi-step path) to ensure markers work in all execution modes.

**Markers processed (in order):**
1. SCHEDULE — create reminder task
2. SCHEDULE_ACTION — create action task
3. PROJECT_ACTIVATE / PROJECT_DEACTIVATE — activate/deactivate project
4. WHATSAPP_QR — trigger WhatsApp QR pairing
5. LANG_SWITCH — persist language preference
6. HEARTBEAT_ADD / HEARTBEAT_REMOVE / HEARTBEAT_INTERVAL — update heartbeat checklist or interval
7. LIMITATION — store limitation, alert owner, add to heartbeat
8. SELF_HEAL — create/update self-healing state, notify owner, schedule verification
9. SELF_HEAL_RESOLVED — delete self-healing state, notify owner

**Logic:** For each marker type: extract from text, process side effects (DB writes, notifications, file updates), strip the marker from text. Mutates `text` in place.

## Free Functions (Module-Level Helpers)

### `fn parse_plan_response(text: &str) -> Option<Vec<String>>`
**Purpose:** Parse the planning provider response into actionable steps.

**Returns:** `None` if the response contains "DIRECT" (any case), has only a single step, or is unparseable. Returns `Some(steps)` for multi-step numbered lists (e.g., `1. Do something`, `2. Do something else`). Non-numbered preamble lines before the numbered list are ignored during parsing.

### `fn extract_schedule_marker(text: &str) -> Option<String>`
**Purpose:** Extract the first `SCHEDULE:` line from response text.

**Logic:** Iterates through lines, finds the first line whose trimmed form starts with `"SCHEDULE:"`, returns it trimmed.

**Returns:** `Some(line)` if found, `None` otherwise.

### `fn parse_schedule_line(line: &str) -> Option<(String, String, String)>`
**Purpose:** Parse a `SCHEDULE:` line into `(description, due_at, repeat)`.

**Format:** `SCHEDULE: <description> | <ISO 8601 datetime> | <once|daily|weekly|monthly|weekdays>`

**Logic:**
1. Strip `"SCHEDULE:"` prefix.
2. Split on `|` into exactly 3 parts.
3. Trim each part.
4. Validate that description and due_at are non-empty.
5. Lowercase the repeat value.
6. Return the tuple.

**Returns:** `None` if format is invalid (wrong number of parts or empty fields).

### `fn strip_schedule_marker(text: &str) -> String`
**Purpose:** Remove all `SCHEDULE:` lines from response text so the marker is not shown to the user.

**Logic:** Filters out any line whose trimmed form starts with `"SCHEDULE:"`, then joins remaining lines and trims the result.

### `fn extract_project_activate(text: &str) -> Option<String>`
**Purpose:** Extract the project name from a `PROJECT_ACTIVATE: <name>` line in response text.

**Logic:** Iterates through lines, finds the first line whose trimmed form starts with `"PROJECT_ACTIVATE:"`, strips the prefix, trims, and returns the project name. Returns `None` if not found or if name is empty.

### `fn has_project_deactivate(text: &str) -> bool`
**Purpose:** Check if response text contains a `PROJECT_DEACTIVATE` marker line.

**Logic:** Returns `true` if any line's trimmed form equals `"PROJECT_DEACTIVATE"`.

### `fn strip_project_markers(text: &str) -> String`
**Purpose:** Remove all `PROJECT_ACTIVATE:` and `PROJECT_DEACTIVATE` lines from response text so the markers are not shown to the user.

**Logic:** Filters out any line whose trimmed form starts with `"PROJECT_ACTIVATE:"` or equals `"PROJECT_DEACTIVATE"`, then joins remaining lines and trims the result.

### `fn extract_lang_switch(text: &str) -> Option<String>`
**Purpose:** Extract the language name from a `LANG_SWITCH:` line in response text.

**Logic:** Iterates through lines, finds the first line whose trimmed form starts with `"LANG_SWITCH:"`, strips the prefix, trims, and returns the language name. Returns `None` if not found or if language is empty.

### `fn strip_lang_switch(text: &str) -> String`
**Purpose:** Remove all `LANG_SWITCH:` lines from response text so the marker is not shown to the user.

**Logic:** Filters out any line whose trimmed form starts with `"LANG_SWITCH:"`, then joins remaining lines and trims the result.

### `struct SelfHealingState`
**Purpose:** State tracked in `~/.omega/self-healing.json` during active self-healing. Derives `Debug`, `Clone`, `Serialize`, `Deserialize`.

**Fields:**
- `anomaly: String` — Description of the anomaly being healed.
- `verification: String` — Concrete verification test to confirm the fix works.
- `iteration: u32` — Current iteration (1-based).
- `max_iterations: u32` — Maximum iterations before escalation (default: 10).
- `started_at: String` — ISO 8601 timestamp when self-healing started.
- `attempts: Vec<String>` — History of what was tried in each iteration.

### `fn extract_self_heal_marker(text: &str) -> Option<String>`
**Purpose:** Extract the first `SELF_HEAL:` line from response text.

**Logic:** Iterates through lines, finds the first line whose trimmed form starts with `"SELF_HEAL:"`, returns it trimmed. Returns `None` if not found.

### `fn parse_self_heal_line(line: &str) -> Option<(String, String)>`
**Purpose:** Parse the description and verification test from a `SELF_HEAL: description | verification test` line.

**Logic:** Strips `"SELF_HEAL:"` prefix, splits on `|` using `splitn(2, '|')`, trims both parts, returns `(description, verification)` tuple. Returns `None` if prefix not found, either part is empty, or no `|` separator.

### `fn has_self_heal_resolved_marker(text: &str) -> bool`
**Purpose:** Check if response text contains a `SELF_HEAL_RESOLVED` marker line.

**Logic:** Returns `true` if any line's trimmed form equals `"SELF_HEAL_RESOLVED"`.

### `fn strip_self_heal_markers(text: &str) -> String`
**Purpose:** Strip all `SELF_HEAL:` and `SELF_HEAL_RESOLVED` lines from response text.

**Logic:** Filters out lines whose trimmed form starts with `"SELF_HEAL:"` or equals `"SELF_HEAL_RESOLVED"`, joins remaining lines, trims.

### `fn self_healing_path() -> Option<PathBuf>`
**Purpose:** Return the path to `~/.omega/self-healing.json`.

**Logic:** Reads `$HOME` env var, returns `Some({home}/.omega/self-healing.json)`. Returns `None` if `HOME` is not set.

### `fn read_self_healing_state() -> Option<SelfHealingState>`
**Purpose:** Read and deserialize the current self-healing state from disk.

**Logic:** Gets the path via `self_healing_path()`, reads the file, deserializes from JSON. Returns `None` if path unavailable, file missing, or JSON invalid.

### `fn write_self_healing_state(state: &SelfHealingState) -> Result`
**Purpose:** Serialize and write the self-healing state to disk.

**Logic:** Gets path, serializes state to pretty JSON, writes to file. Returns error if `HOME` not set or I/O fails.

### `fn delete_self_healing_state() -> Result`
**Purpose:** Delete the self-healing state file.

**Logic:** Gets path, removes the file if it exists. Returns error if `HOME` not set or deletion fails.

### `fn detect_repo_path() -> Option<String>`
**Purpose:** Auto-detect the Omega source code repository path from the binary location.

**Logic:** Gets the path of the current executable via `std::env::current_exe()`, navigates up 3 parent directories (binary → `target/release/` → `target/` → repo root), checks if `Cargo.toml` exists at that level. Returns `Some(path)` if found, `None` otherwise.

**Returns:** `Some(path_string)` if the repo root is detected, `None` if executable path is unavailable or `Cargo.toml` is not found.

### `fn self_heal_follow_up(anomaly: &str, verification: &str) -> String`
**Purpose:** Build the self-healing follow-up task description with repo context. Centralizes the follow-up prompt used by both `process_markers()` and `scheduler_loop`.

**Parameters:**
- `anomaly: &str` - Description of the anomaly being healed.
- `verification: &str` - Concrete verification test to confirm the fix.

**Returns:** A formatted task description that instructs the AI to: read `self-healing.json`, run the verification test, emit `SELF_HEAL_RESOLVED` on success, or continue fixing on failure. If `detect_repo_path()` finds the repo, appends a hint with the source code path and nix build command.

### `fn read_heartbeat_file() -> Option<String>`
**Purpose:** Read `~/.omega/HEARTBEAT.md` if it exists, for use as a heartbeat checklist.

**Logic:**
1. Get `$HOME` env var.
2. Read `{home}/.omega/HEARTBEAT.md`.
3. Return `None` if file does not exist, is unreadable, or has only whitespace.
4. Return `Some(content)` otherwise.

### `enum HeartbeatAction`
**Purpose:** Represents an action extracted from a `HEARTBEAT_ADD:`, `HEARTBEAT_REMOVE:`, or `HEARTBEAT_INTERVAL:` marker.

**Variants:**
- `Add(String)` — Item to add to the heartbeat checklist.
- `Remove(String)` — Keyword to match and remove from the heartbeat checklist.
- `SetInterval(u64)` — Dynamically change the heartbeat interval (minutes, 1–1440).

### `fn extract_heartbeat_markers(text: &str) -> Vec<HeartbeatAction>`
**Purpose:** Extract all `HEARTBEAT_ADD:`, `HEARTBEAT_REMOVE:`, and `HEARTBEAT_INTERVAL:` markers from response text.

**Logic:** Iterates through lines, finds lines whose trimmed form starts with `"HEARTBEAT_ADD:"`, `"HEARTBEAT_REMOVE:"`, or `"HEARTBEAT_INTERVAL:"`, strips the prefix, trims, and collects into a `Vec<HeartbeatAction>`. Empty items (marker with no description) are skipped. For `HEARTBEAT_INTERVAL:`, the value must parse as a `u64` between 1 and 1440 (inclusive); invalid values are silently ignored.

### `fn strip_heartbeat_markers(text: &str) -> String`
**Purpose:** Remove all `HEARTBEAT_ADD:`, `HEARTBEAT_REMOVE:`, and `HEARTBEAT_INTERVAL:` lines from response text so the markers are not shown to the user.

**Logic:** Filters out any line whose trimmed form starts with `"HEARTBEAT_ADD:"`, `"HEARTBEAT_REMOVE:"`, or `"HEARTBEAT_INTERVAL:"`, then joins remaining lines and trims the result.

### `fn apply_heartbeat_changes(actions: &[HeartbeatAction])`
**Purpose:** Apply heartbeat add/remove actions to `~/.omega/HEARTBEAT.md`.

**Logic:**
1. Get `$HOME` env var. Return silently if not set.
2. Read existing file lines (or start with empty vec if file does not exist).
3. For each `Add(item)`: check if item already exists (case-insensitive, ignoring `- ` prefix). If not, append `- {item}`.
4. For each `Remove(item)`: remove all non-comment lines whose content contains the item (case-insensitive partial match). Comment lines (starting with `#`) are never removed.
5. Ensure `~/.omega/` directory exists.
6. Write the updated lines back to the file.

### `const IMAGE_EXTENSIONS: &[&str]`
**Purpose:** List of image file extensions recognized for workspace diff: `["png", "jpg", "jpeg", "gif", "webp"]`.

### `fn snapshot_workspace_images(workspace: &Path) -> HashSet<PathBuf>`
**Purpose:** Snapshot top-level image files in the workspace directory.

**Parameters:**
- `workspace: &Path` - Path to the workspace directory.

**Returns:** `HashSet<PathBuf>` containing paths to image files. Returns empty set on any error (non-existent dir, permission issues).

**Logic:**
1. Read the workspace directory via `std::fs::read_dir()`. Return empty set on error.
2. Filter to regular files whose extension (case-insensitive) matches `IMAGE_EXTENSIONS`.
3. Collect into a `HashSet<PathBuf>`.

### `fn ensure_inbox_dir(data_dir: &str) -> PathBuf`
**Purpose:** Create and return the inbox directory path at `{data_dir}/workspace/inbox/`.

**Parameters:**
- `data_dir: &str` - The Omega data directory (e.g., `~/.omega`).

**Returns:** `PathBuf` pointing to `{data_dir}/workspace/inbox/`.

**Logic:**
1. Build the path `{data_dir}/workspace/inbox/`.
2. Create the directory (and parents) if it does not exist via `std::fs::create_dir_all()`.
3. Return the path.

### `fn save_attachments_to_inbox(inbox: &Path, attachments: &[Attachment]) -> Vec<PathBuf>`
**Purpose:** Save Image-type attachments to the inbox directory on disk and return the list of saved file paths.

**Parameters:**
- `inbox: &Path` - Path to the inbox directory.
- `attachments: &[Attachment]` - Slice of attachments from the incoming message.

**Returns:** `Vec<PathBuf>` containing paths to saved image files. Non-image attachments are skipped.

**Logic:**
1. Iterate over attachments.
2. Skip any attachment whose `attachment_type` is not `AttachmentType::Image`.
3. For each image attachment, write `attachment.data` to `{inbox}/{attachment.filename}`.
4. Log success at info level, failures at warn level.
5. Collect and return the paths of successfully written files.

### `fn cleanup_inbox_images(paths: &[PathBuf])`
**Purpose:** Remove temporary inbox image files after the provider response has been processed.

**Parameters:**
- `paths: &[PathBuf]` - Slice of file paths to remove.

**Returns:** None (void).

**Logic:**
1. Iterate over paths.
2. Remove each file via `std::fs::remove_file()`.
3. Log failures at warn level but continue removing remaining files.

### `fn status_messages(lang: &str) -> (&'static str, &'static str)`
**Purpose:** Return localized status messages for the delayed provider nudge.

**Parameters:**
- `lang: &str` - Language name (e.g., "English", "Spanish").

**Returns:** Tuple of `(first_nudge, still_working)` static strings.

**Logic:** Match on language name. Supports English, Spanish, Portuguese, French, German, Italian, Dutch, Russian. Unknown languages fall back to English.

### `fn friendly_provider_error(raw: &str) -> String`
**Purpose:** Map raw provider error messages to user-friendly messages.

**Parameters:**
- `raw: &str` - The raw error message from the provider or task join error.

**Returns:** `String` - A friendly, user-facing error message.

**Logic:**
1. If `raw` contains "timed out" or similar timeout indicators, return "I took too long to respond. Please try again..."
2. Otherwise, return "Something went wrong. Please try again."

### `fn is_within_active_hours(start: &str, end: &str) -> bool`
**Purpose:** Check if the current local time is within the active hours window.

**Parameters:**
- `start: &str` - Start time in `"HH:MM"` format.
- `end: &str` - End time in `"HH:MM"` format.

**Logic:**
1. Get current local time as `"HH:MM"` string via `chrono::Local::now()`.
2. If `start <= end` (normal range, e.g., `"08:00"` to `"22:00"`): return `now >= start && now < end`.
3. If `start > end` (midnight wrap, e.g., `"22:00"` to `"06:00"`): return `now >= start || now < end`.

**Dependencies:** `chrono` crate for local time formatting.

## Message Flow Diagram

```
[Telegram/WhatsApp] → [Channel Receiver] → [MPSC Channel]
                                               ↓
                                        [Gateway Event Loop]
                                               ↓
                                          [handle_message()]
                                               ↓
                    ┌──────────────────────────┼──────────────────────────┐
                    ↓                          ↓                          ↓
            [1. Auth Check]         [2. Sanitize]            [3. Command?]
                    ↓                          ↓                          ↓
              [ALLOWED?]              [Clean Text]          [Yes] → [Handle Cmd]
              /        \                      ↓                      [Send Response]
          [No]        [Yes]          [4. Typing Indicator]          [Return]
            ↓            ↓                      ↓
        [Deny]      [Continue]         [Spawn Repeat Task]
         [Audit]         ↓                     ↓
        [Send Msg]   [5. Build Context]     [Continue]
        [Return]          ↓                     ↓
                    [With History + Facts] [5a. Provider.complete()]
                           ↓                   ↓
                      [Enriched CTX]    [Get Response/Error]
                           ↓                   ↓
                           └───────────────────┤
                                               ↓
                                          [Error?]
                                          /      \
                                      [Yes]     [No]
                                        ↓         ↓
                                    [Send Err] [Abort Typing]
                                    [Audit Err]    ↓
                                    [Abort Type]  [5b. Extract SCHEDULE:]
                                    [Return]       ↓
                                            [create_task() if marker]
                                            [strip marker from response]
                                                   ↓
                                            [6. Store Exchange]
                                                   ↓
                                            [7. Audit Log (Success)]
                                                   ↓
                                            [8. Send Response]
                                                   ↓
                                                [Done]

--- Background Tasks ---

[Scheduler Loop]   ←── polls every poll_interval_secs
       ↓
  get_due_tasks()
       ↓
  [For each due task] → channel.send("Reminder: ...")
       ↓                       ↓
  complete_task()         [Advance due_at for recurring]

[Heartbeat Loop]   ←── polls every interval_minutes * 60s
       ↓
  is_within_active_hours()
       ↓ (if active)
  read_heartbeat_file()
       ↓ (None → skip, no API call)
  enrich prompt with memory.get_all_facts() + memory.get_all_recent_summaries(3)
       ↓
  provider.complete(enriched heartbeat prompt)
       ↓
  [HEARTBEAT_OK?] → suppress / [Alert?] → channel.send(alert)
```

## Error Handling Strategy

### Error Propagation Levels

1. **Critical Errors (Early Return):**
   - Channel startup failure → breaks gateway initialization.
   - Auth denial → deny message sent, audit logged, message dropped.
   - Context build failure → error message sent, message dropped.
   - Provider error → error message sent, audit logged, message dropped.

2. **Non-Critical Errors (Log and Continue):**
   - Memory store errors → logged, response still sent if provider succeeded.
   - Audit logging errors → logged, processing continues.
   - Channel send errors → logged, does not block completion.
   - Background summarization errors → logged, loop continues.
   - Idle conversation query errors → logged, loop continues.

3. **Error Auditing:**
   - All auth denials are logged with `AuditStatus::Denied`.
   - All provider errors are logged with `AuditStatus::Error`.
   - All successful exchanges are logged with `AuditStatus::Ok`.

### Error Types Used
- `anyhow::anyhow!()` for wrapping errors in run().
- `anyhow::Error` for Result types.
- `sqlx` errors from database operations (caught with `.ok().flatten()`).
- Tracing logs: `error!()`, `warn!()`, `info!()`.

## Async Runtime Patterns

### Concurrency Model
- **Non-blocking message dispatch:** The gateway dispatches messages via `dispatch_message()` which spawns a `tokio::spawn()` task per sender. Messages for different senders are processed concurrently; messages for the same sender are serialized via the `active_senders` buffer.
- **Multiple channels:** Each channel listener runs in its own `tokio::spawn()` task.
- **Background summarizer:** Runs in a dedicated `tokio::spawn()` task.
- **Scheduler loop:** Conditionally runs in a dedicated `tokio::spawn()` task (when `scheduler_config.enabled`).
- **Heartbeat loop:** Conditionally runs in a dedicated `tokio::spawn()` task (when `heartbeat_config.enabled`).
- **Typing repeater:** For each message, a separate `tokio::spawn()` task repeats typing every 5 seconds.
- **Provider task:** For each message, `provider.complete()` is spawned via `tokio::spawn()` to run in the background.
- **Status updater:** For each message, a delayed status updater task is spawned that sends a localized first nudge after 15 seconds, then periodic localized "Still working..." messages every 120 seconds; aborted when the provider result arrives. If the provider responds within 15 seconds, no status message is sent. Messages are localized to the user's `preferred_language` fact via `status_messages()`.

### Synchronization
- **MPSC Channel:** All incoming messages from channels are collected on a single 256-capacity mpsc queue.
- **Arc Sharing:** Provider, channels, and the gateway itself are shared via `Arc` for thread-safe access.
- **Mutex:** The `active_senders` field uses a `tokio::sync::Mutex` to coordinate per-sender message buffering across concurrent tasks. The lock is held only briefly for buffer check/update operations, never across async provider calls.

### Shutdown Coordination
- **Signal handling:** `tokio::signal::ctrl_c()` breaks the main loop.
- **Task abortion:** Background summarizer is aborted via `bg_handle.abort()`. Scheduler and heartbeat handles are aborted if present.
- **Channel stopping:** Each channel's `stop()` method is called.
- **Graceful conversation closure:** All active conversations are summarized before shutdown completes.

## Channel Integration

### Channel Trait Requirements
- **`start() -> Result<mpsc::Receiver<IncomingMessage>>`:** Returns a receiver for messages from that channel. Must be called once at gateway startup.
- **`send(OutgoingMessage) -> Result<()>`:** Sends a message back to the user.
- **`send_typing(target) -> Result<()>`:** Sends a typing indicator. Called repeatedly every 5 seconds.
- **`stop() -> Result<()>`:** Cleanly shuts down the channel.

### Telegram Integration Details
- Auth is enforced via `channel_config.telegram.allowed_users` list.
- Empty list allows all users (for testing).
- Non-empty list restricts to specified user IDs.
- `sender_id` is parsed as i64.

## Provider Integration

### Provider Trait Requirements
- **`name() -> &'static str`:** Returns the provider name (e.g., "Claude Code CLI").
- **`complete(Context) -> Result<Response>`:** Takes a context with full prompt and returns a response.

### Response Metadata
The response includes:
- `text: String` - The assistant's reply.
- `metadata.provider_used: String` - Name of the provider (e.g., "Claude Code CLI").
- `metadata.model: Option<String>` - Model name (e.g., "claude-opus-4-6").
- `metadata.processing_time_ms: u32` - Time taken by the provider.
- `reply_target: Option<String>` - Set to incoming message's reply_target for threading.

## Memory Integration

### Store Operations Used
- **`build_context(&IncomingMessage, &str) -> Result<Context>`:** Builds enriched context with history and facts, using the provided base system prompt.
- **`store_exchange(&IncomingMessage, &OutgoingMessage) -> Result<()>`:** Saves the message pair to conversation history.
- **`store_fact(&sender_id, &key, &value) -> Result<()>`:** Stores an extracted fact about a user.
- **`get_conversation_messages(&conversation_id) -> Result<Vec<(String, String)>>`:** Fetches all messages in a conversation.
- **`close_conversation(&conversation_id, &summary) -> Result<()>`:** Marks a conversation as closed with a summary.
- **`find_idle_conversations() -> Result<Vec<(String, String, String)>>`:** Finds conversations inactive for a threshold.
- **`find_all_active_conversations() -> Result<Vec<(String, String, String)>>`:** Finds all currently active conversations.
- **`pool() -> &SqlitePool`:** Provides direct database access for queries.
- **`create_task(&channel, &sender_id, &reply_target, &description, &due_at, repeat) -> Result<String>`:** Creates a scheduled task. Called from handle_message Stage 5b.
- **`get_due_tasks() -> Result<Vec<(String, String, String, String, Option<String>)>>`:** Fetches tasks where status is pending and due_at <= now. Called by scheduler_loop.
- **`complete_task(&id, repeat) -> Result<()>`:** Marks a one-shot task as delivered or advances due_at for recurring tasks. Called by scheduler_loop.
- **`get_all_facts() -> Result<Vec<(String, String)>>`:** Gets all facts across all users (excluding `welcomed`). Called by heartbeat_loop for context enrichment.
- **`get_all_recent_summaries(limit) -> Result<Vec<(String, String)>>`:** Gets recent conversation summaries across all users. Called by heartbeat_loop with `limit = 3` for context enrichment.

## Configuration Parameters

### AuthConfig
- `enabled: bool` - Whether authentication is enforced.
- `deny_message: String` - Message to send when auth fails.

### ChannelConfig
- `telegram: Option<TelegramConfig>` - Telegram-specific settings.
  - `allowed_users: Vec<i64>` - Whitelist of user IDs. Empty = allow all.

### HeartbeatConfig
- `enabled: bool` - Whether the heartbeat loop is spawned.
- `interval_minutes: u64` - Minutes between heartbeat checks (default: 30).
- `active_start: String` - Start of active hours window (`"HH:MM"` format). Empty = always active.
- `active_end: String` - End of active hours window (`"HH:MM"` format). Empty = always active.
- `channel: String` - Channel name for alert delivery (e.g., `"telegram"`).
- `reply_target: String` - Platform-specific delivery target (e.g., chat ID).

### SchedulerConfig
- `enabled: bool` - Whether the scheduler loop is spawned (default: true).
- `poll_interval_secs: u64` - Seconds between scheduler polls (default: 60).

## Logging and Observability

### Log Levels Used
- **INFO:** Gateway startup, channel starts, message previews, conversation summaries, shutdown.
- **WARN:** Auth denials, sanitization warnings, shutdown summarization errors, channel stop errors, conversation summarization errors.
- **ERROR:** Context build failures, provider errors, memory storage errors, channel send errors, idle conversation query errors.

### Audit Logging
All interactions are logged to SQLite with:
- Channel name, sender_id, sender_name.
- Input text and output text.
- Provider name and model.
- Processing time in milliseconds.
- Status (Ok, Denied, Error).
- Denial reason (if denied).

## Security Considerations

1. **Input Sanitization:** All user input is sanitized before reaching the provider to neutralize injection patterns.
2. **Auth Enforcement:** Access control is enforced before any processing begins.
3. **Audit Trail:** All interactions are logged for security review.
4. **No Secrets in Logs:** User text is logged but no API keys or credentials are logged.
5. **Error Suppression:** Detailed errors are logged but user-facing messages are generic to avoid info leaks.

## Performance Characteristics

- **Non-blocking Gateway:** Messages for different senders are processed concurrently via `tokio::spawn()`. Messages for the same sender are serialized to maintain conversation coherence, with buffered messages processed in order after the active call completes.
- **Concurrent Channels:** Multiple channels can deliver messages concurrently via tokio tasks.
- **Background Summarization:** Idle conversation summarization happens every 60 seconds without blocking the main loop.
- **MPSC Buffering:** Up to 256 incoming messages can be buffered while waiting for dispatch.

## Dependencies

### External Crates
- `anyhow` - Error handling.
- `tokio` - Async runtime, synchronization primitives.
- `tracing` - Structured logging.
- `sqlx` - Database queries (via Store).
- `chrono` - Local time formatting for active hours check.

### Internal Dependencies
- `omega_core` - Core types, traits, config (including `Prompts`), sanitization.
- `omega_memory` - Store, AuditLogger, AuditEntry, AuditStatus.
- `crate::commands` - Command parsing and handling.

## Invariants

1. Only one task in the main event loop at a time (tokio::select!).
2. All channels are started before the main loop.
3. The background summarizer is spawned and never joined (infinite loop).
4. Auth is checked before any message processing.
5. Sanitization happens before command dispatch and provider call.
6. Response is sent to the channel that received the message.
7. All exchanges are stored in memory before audit logging.
8. Typing indicator is aborted when response is sent or on error.
9. On shutdown, all active conversations are summarized, all background tasks are aborted, and all channels are stopped.
10. SCHEDULE: markers are stripped from the response before sending to the user.
11. LANG_SWITCH: markers are stripped from the response before sending to the user. The extracted language is persisted as a `preferred_language` fact.
12. Scheduler loop only runs when `scheduler_config.enabled` is true.
13. Heartbeat loop only runs when `heartbeat_config.enabled` is true.
14. Heartbeat alerts are suppressed when the provider response contains `HEARTBEAT_OK` (after stripping markdown formatting).
15. Status updater is aborted when provider result arrives.
16. When `is_group` is true and the provider response is `SILENT`, the response is suppressed (not stored, not audited, not sent).
17. Platform formatting hints are injected into the system prompt based on `incoming.channel` (WhatsApp avoids markdown tables/headers; Telegram supports full markdown).
18. Group chat rules are injected into the system prompt when `incoming.is_group` is `true`.
19. Heartbeat loop skips API calls entirely when no checklist file (`~/.omega/HEARTBEAT.md`) is configured.
20. Heartbeat prompt is enriched with user facts and recent conversation summaries from memory.
21. HEARTBEAT_ADD:, HEARTBEAT_REMOVE:, and HEARTBEAT_INTERVAL: markers are stripped from the response before sending to the user. Adds are appended to `~/.omega/HEARTBEAT.md`; removes use case-insensitive partial matching and never remove comment lines. HEARTBEAT_INTERVAL: updates the shared `AtomicU64` interval (valid range: 1–1440 minutes) and sends a confirmation notification to the owner via the heartbeat channel.
22. The current heartbeat checklist is injected into the system prompt so the provider knows what is already monitored.
23. When `sandbox_prompt` is `Some`, the sandbox constraint text is prepended to the system prompt before context building.
24. The startup log includes the active sandbox mode for operational visibility.
25. After sending the text response, new image files created in the workspace by the provider are delivered via `channel.send_photo()` and then deleted from the workspace.
26. Incoming image attachments are saved to `{data_dir}/workspace/inbox/` before the provider call (Stage 2a) and cleaned up after the response is sent (Stage 9).
27. Messages for different senders are dispatched concurrently via `tokio::spawn()`. Messages for the same sender are serialized: only one provider call per sender at a time, with additional messages buffered and processed in order.
28. When a message arrives for a busy sender, a "Got it, I'll get to this next." acknowledgment is sent immediately.
29. Classify-and-route: every message triggers a context-enriched classification call (using the fast model with active project, last 3 messages, and skill names); DIRECT messages use `model_fast`, multi-step plans use `model_complex`. Multi-step plans are executed autonomously with per-step progress, retry (up to 3 attempts), and a final summary.
30. Planning steps are tracked in-memory (ephemeral) and are not persisted to the database.
31. Model routing: `context.model` is set by classify-and-route before the provider call. The provider resolves the effective model via `context.model.as_deref().unwrap_or(&self.model)`.
32. SELF_HEAL: markers (format: `SELF_HEAL: description | verification test`) are processed after LIMITATION markers. The gateway parses both description and verification test, creates or updates `~/.omega/self-healing.json` (including the `verification` field), enforces max 10 iterations in code, schedules follow-up action tasks (2 min delay) with the verification test embedded in the prompt, and sends owner notifications via heartbeat channel. At max iterations, sends escalation alert and preserves state file. Processed in `handle_message` (direct), `execute_steps` (multi-step), and `scheduler_loop` — all via `process_markers()`.
33. SELF_HEAL_RESOLVED markers trigger deletion of `~/.omega/self-healing.json` and send a resolution notification to the owner via heartbeat channel. Processed in `handle_message` (direct), `execute_steps` (multi-step), and `scheduler_loop` — all via `process_markers()`.
34. All response markers (SCHEDULE, SCHEDULE_ACTION, PROJECT, LANG_SWITCH, HEARTBEAT, LIMITATION, SELF_HEAL, SELF_HEAL_RESOLVED) are processed via the unified `process_markers()` method, ensuring they work in both the direct response path (`handle_message`) and the multi-step execution path (`execute_steps`).
35. All system markers must use their exact English prefix regardless of conversation language. The gateway parses markers as literal string prefixes — a translated or paraphrased marker is a silent failure. The system prompt explicitly instructs the AI: "Speak to the user in their language; speak to the system in markers."

## Tests

### `test_friendly_provider_error_timeout`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `friendly_provider_error()` returns the timeout-specific friendly message when the raw error string contains a timeout indicator.

### `test_friendly_provider_error_generic`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `friendly_provider_error()` returns the generic friendly message ("Something went wrong. Please try again.") when the raw error string does not contain a timeout indicator.

### `test_status_messages_all_languages`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `status_messages()` returns non-empty nudge and still-working strings for all 8 supported languages.

### `test_status_messages_unknown_falls_back_to_english`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `status_messages()` falls back to English for unrecognized language names.

### `test_status_messages_spanish`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `status_messages("Spanish")` returns Spanish-language status messages.

### `test_read_heartbeat_file_returns_none_when_missing`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `read_heartbeat_file()` returns `None` when `~/.omega/HEARTBEAT.md` does not exist or is empty, confirming the skip-when-no-checklist behavior.

### `test_bundled_system_prompt_contains_identity_soul_system`

**Type:** Synchronous unit test (`#[test]`)

Verifies that the bundled `SYSTEM_PROMPT.md` (via `include_str!`) contains all three sections (`## Identity`, `## Soul`, `## System`) with key phrases from each.

### `test_bundled_facts_prompt_guided_schema`

**Type:** Synchronous unit test (`#[test]`)

Verifies that the bundled `SYSTEM_PROMPT.md` (via `include_str!`) contains the guided fact-extraction schema with canonical fields like "preferred_name", "pronouns", and "timezone".

### `test_extract_heartbeat_add`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `extract_heartbeat_markers()` correctly extracts a single `HEARTBEAT_ADD:` marker from response text.

### `test_extract_heartbeat_remove`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `extract_heartbeat_markers()` correctly extracts a single `HEARTBEAT_REMOVE:` marker from response text.

### `test_extract_heartbeat_multiple`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `extract_heartbeat_markers()` extracts both `HEARTBEAT_ADD:` and `HEARTBEAT_REMOVE:` markers from the same response text.

### `test_extract_heartbeat_empty_ignored`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `extract_heartbeat_markers()` ignores markers with empty descriptions (e.g., `HEARTBEAT_ADD: ` with trailing whitespace only).

### `test_strip_heartbeat_markers`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `strip_heartbeat_markers()` removes `HEARTBEAT_ADD:` lines from response text while preserving other lines.

### `test_strip_heartbeat_both_types`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `strip_heartbeat_markers()` removes both `HEARTBEAT_ADD:` and `HEARTBEAT_REMOVE:` lines from the same response text.

### `test_extract_heartbeat_interval`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `extract_heartbeat_markers()` correctly extracts a `HEARTBEAT_INTERVAL:` marker as `HeartbeatAction::SetInterval(15)`.

### `test_extract_heartbeat_interval_invalid`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `extract_heartbeat_markers()` ignores invalid interval values: zero, negative, non-numeric, and values above 1440. Confirms boundary values (1 and 1440) are accepted.

### `test_strip_heartbeat_interval`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `strip_heartbeat_markers()` removes `HEARTBEAT_INTERVAL:` lines from response text while preserving other lines.

### `test_extract_heartbeat_mixed`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `extract_heartbeat_markers()` extracts all three marker types (`HEARTBEAT_INTERVAL:`, `HEARTBEAT_ADD:`, `HEARTBEAT_REMOVE:`) from the same response text in the correct order.

### `test_apply_heartbeat_add`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `apply_heartbeat_changes()` adds new items to `~/.omega/HEARTBEAT.md`, preserves existing items, and prevents duplicate adds (case-insensitive). Uses a temporary directory with overridden `$HOME`.

### `test_apply_heartbeat_remove`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `apply_heartbeat_changes()` removes matching items from `~/.omega/HEARTBEAT.md` using case-insensitive partial matching, preserves comment lines, and keeps non-matching items. Uses a temporary directory with overridden `$HOME`.

### `test_snapshot_workspace_images_finds_images`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `snapshot_workspace_images()` finds `.png` and `.jpg` files but ignores `.txt` files.

### `test_snapshot_workspace_images_empty_dir`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `snapshot_workspace_images()` returns an empty set for an empty directory.

### `test_snapshot_workspace_images_nonexistent_dir`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `snapshot_workspace_images()` returns an empty set gracefully for a non-existent directory.

### `test_snapshot_workspace_images_all_extensions`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `snapshot_workspace_images()` detects all 5 supported image extensions (png, jpg, jpeg, gif, webp).

### `test_ensure_inbox_dir`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `ensure_inbox_dir()` creates the `{data_dir}/workspace/inbox/` directory and returns the correct path. Uses a temporary directory.

### `test_save_and_cleanup_inbox_images`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `save_attachments_to_inbox()` writes Image-type attachments to disk, returns the correct paths, and that `cleanup_inbox_images()` removes the files afterwards. Uses a temporary directory.

### `test_save_attachments_skips_non_images`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `save_attachments_to_inbox()` skips non-Image attachment types (e.g., audio, document) and only saves Image-type attachments.

### `test_parse_plan_response_direct`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `parse_plan_response()` returns `None` when the response contains "DIRECT" (any case).

### `test_parse_plan_response_numbered_list`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `parse_plan_response()` returns `Some(vec)` for a multi-step numbered list response.

### `test_parse_plan_response_single_step`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `parse_plan_response()` returns `None` when the response contains only a single step.

### `test_parse_plan_response_with_preamble`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `parse_plan_response()` correctly parses a numbered list that has non-numbered preamble text before it, returning the steps while ignoring the preamble.

### `test_extract_self_heal_marker`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `extract_self_heal_marker()` extracts the first `SELF_HEAL:` line (including pipe-separated verification test) from response text.

### `test_extract_self_heal_marker_none`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `extract_self_heal_marker()` returns `None` when no `SELF_HEAL:` marker is present.

### `test_parse_self_heal_line`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `parse_self_heal_line()` extracts the `(description, verification)` tuple from a `SELF_HEAL: description | verification test` line.

### `test_parse_self_heal_line_empty`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `parse_self_heal_line()` returns `None` for empty descriptions, whitespace-only, non-matching lines, missing verification (`desc only`, `desc |`, `| verification`).

### `test_has_self_heal_resolved_marker`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `has_self_heal_resolved_marker()` returns `true` when `SELF_HEAL_RESOLVED` is present.

### `test_has_self_heal_resolved_marker_none`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `has_self_heal_resolved_marker()` returns `false` when no `SELF_HEAL_RESOLVED` is present.

### `test_strip_self_heal_markers`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `strip_self_heal_markers()` removes `SELF_HEAL:` lines (with pipe format) while preserving other content.

### `test_strip_self_heal_markers_resolved`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `strip_self_heal_markers()` removes `SELF_HEAL_RESOLVED` lines while preserving other content.

### `test_strip_self_heal_markers_both`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `strip_self_heal_markers()` removes both `SELF_HEAL:` (with pipe format) and `SELF_HEAL_RESOLVED` lines from the same text.

### `test_self_healing_state_serde_roundtrip`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `SelfHealingState` (including `verification` field) can be serialized to JSON and deserialized back with all fields preserved.

### `test_self_heal_full_flow_simulation`

**Type:** Synchronous unit test (`#[test]`)

Verifies the full SELF_HEAL flow: marker extraction → parsing → state creation (with verification) → state write/read roundtrip → follow-up description → SELF_HEAL_RESOLVED detection → state deletion.

### `test_self_healing_state_old_format_graceful_fallback`

**Type:** Synchronous unit test (`#[test]`)

Verifies backward compatibility: deserializing a `SelfHealingState` JSON without the `verification` field falls back to an empty string via `#[serde(default)]`.

### `test_self_heal_old_marker_format_rejected`

**Type:** Synchronous unit test (`#[test]`)

Verifies that the old marker format (`SELF_HEAL: description` without pipe separator) is rejected by `parse_self_heal_line()`.

### `test_self_heal_verification_with_internal_pipes`

**Type:** Synchronous unit test (`#[test]`)

Verifies that verification tests containing internal pipe characters are preserved correctly (only splits on the first `|`).

### `test_detect_repo_path`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `detect_repo_path()` returns a `Some` value containing "omega" when running from within the project directory.

### `test_self_heal_follow_up_content`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `self_heal_follow_up()` includes the anomaly, verification test, SELF_HEAL_RESOLVED instruction, and continue-on-failure instruction in its output.
