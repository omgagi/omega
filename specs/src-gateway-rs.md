# Specification: src/gateway.rs

## File Path
`/Users/isudoajl/ownCloud/Projects/omega/src/gateway.rs`

## Purpose
Gateway is the central event loop orchestrator that connects messaging channels, memory persistence, and AI providers. It implements the complete message processing pipeline with authentication, sanitization, context building, provider delegation, audit logging, and graceful shutdown.

## Architecture Overview

### Core Responsibility
The gateway manages the asynchronous event loop that processes incoming messages through a deterministic pipeline:

```
Message → Auth → Sanitize → Command Check → Typing → Context → MCP Trigger Match →
Provider (MCP settings write → CLI → MCP cleanup) → Memory Store → Audit Log → Send
```

The gateway runs continuously, listening for messages from registered channels via an mpsc channel, and spawns a background task for periodic conversation summarization.

## Data Structures

### Gateway Struct
```rust
pub struct Gateway {
    provider: Arc<dyn Provider>,              // AI backend (Claude Code, Anthropic, etc.)
    channels: HashMap<String, Arc<dyn Channel>>,  // Messaging platforms (Telegram, WhatsApp)
    memory: Store,                             // SQLite conversation/fact storage
    audit: AuditLogger,                        // Event audit trail
    auth_config: AuthConfig,                   // Authentication rules
    channel_config: ChannelConfig,             // Per-channel configuration
    heartbeat_config: HeartbeatConfig,         // Periodic AI check-in settings
    scheduler_config: SchedulerConfig,         // Scheduled task delivery settings
    prompts: Prompts,                          // Externalized prompts & welcome messages
    projects: Vec<omega_skills::Project>,       // Per-project custom instructions
    sandbox_mode: String,                      // Display name of active sandbox mode
    sandbox_prompt: Option<String>,            // Sandbox constraint text for system prompt
    uptime: Instant,                           // Server start time
}
```

**Fields:**
- `provider`: Shared reference to the configured AI provider. Must implement the `Provider` trait.
- `channels`: Map of channel names to channel implementations. Each channel independently listens for messages.
- `memory`: Shared SQLite-backed store for conversation history, facts, and metadata.
- `audit`: Logger that records all interactions for security and debugging.
- `auth_config`: Global authentication policy (enabled flag, deny message).
- `channel_config`: Per-channel settings (Telegram allowed_users list).
- `heartbeat_config`: Periodic heartbeat check-in configuration (interval, active hours, channel, reply target).
- `scheduler_config`: Scheduled task delivery configuration (enabled flag, poll interval).
- `prompts`: Externalized prompts and welcome messages, loaded from `~/.omega/SYSTEM_PROMPT.md` and `~/.omega/WELCOME.toml` at startup. Falls back to hardcoded defaults if files are missing.
- `projects`: Per-project custom instructions loaded from `~/.omega/projects/`.
- `sandbox_mode`: Display name of the active sandbox mode (e.g., `"sandbox"`, `"rx"`, `"rwx"`). Used in startup logging and passed to `CommandContext` for `/status`.
- `sandbox_prompt`: Optional sandbox constraint text injected into the system prompt before context building. Generated by `SandboxMode::prompt_constraint()`. When `Some`, prepended to the system prompt to instruct the provider about filesystem restrictions. When `None` (rwx mode), no constraint is added.
- `uptime`: Tracks server start time for uptime calculations in commands.

## Functions

### Public Methods

#### `new(provider, channels, memory, auth_config, channel_config, heartbeat_config, scheduler_config, prompts, projects, sandbox_mode, sandbox_prompt) -> Self`
**Purpose:** Construct a new gateway instance.

**Parameters:**
- `provider: Arc<dyn Provider>` - The AI backend (typically Claude Code CLI provider).
- `channels: HashMap<String, Arc<dyn Channel>>` - Map of initialized channel implementations.
- `memory: Store` - SQLite store initialized with database pool.
- `auth_config: AuthConfig` - Authentication configuration.
- `channel_config: ChannelConfig` - Per-channel configuration.
- `heartbeat_config: HeartbeatConfig` - Heartbeat check-in configuration.
- `scheduler_config: SchedulerConfig` - Scheduled task delivery configuration.
- `prompts: Prompts` - Externalized prompts and welcome messages (loaded from `~/.omega/` files or defaults).
- `projects: Vec<omega_skills::Project>` - Per-project custom instructions loaded from `~/.omega/projects/`.
- `sandbox_mode: String` - Display name of the active sandbox mode (e.g., `"sandbox"`, `"rx"`, `"rwx"`).
- `sandbox_prompt: Option<String>` - Optional sandbox constraint text for system prompt injection.

**Returns:** New `Gateway` instance.

**Logic:**
- Creates an `AuditLogger` from the memory pool.
- Captures current time as `uptime`.
- Stores all parameters as instance fields.

**Error Handling:** None (infallible). Has `#[allow(clippy::too_many_arguments)]` attribute.

#### `async fn run(&mut self) -> anyhow::Result<()>`
**Purpose:** Start the gateway event loop and run until shutdown signal.

**Parameters:** None.

**Returns:** `anyhow::Result<()>` (Ok on graceful shutdown, Err on critical failure).

**Logic:**
1. Log gateway initialization with provider name, channel names, auth status, and sandbox mode.
2. Create an mpsc channel with capacity 256 for incoming messages.
3. For each registered channel:
   - Call `channel.start()` to get a receiver for that channel's messages.
   - Spawn a background task that forwards all messages from the channel receiver to the gateway's main mpsc channel.
   - Log successful channel start.
4. Drop the sender to signal EOF when all channels close.
5. Spawn a background summarization task via `tokio::spawn(background_summarizer())`.
6. If `scheduler_config.enabled`, spawn `scheduler_loop()` via `tokio::spawn()`. Store handle as `Option<JoinHandle<()>>`.
7. If `heartbeat_config.enabled`, spawn `heartbeat_loop()` via `tokio::spawn()`. Store handle as `Option<JoinHandle<()>>`.
8. Enter the main event loop using `tokio::select!`:
   - Wait for incoming messages via `rx.recv()` and call `handle_message()`.
   - Wait for Ctrl+C signal via `tokio::signal::ctrl_c()`.
   - On shutdown signal, break from loop.
9. Call `shutdown(bg_handle, sched_handle, hb_handle)` for graceful cleanup.
10. Return Ok(()).

**Async Patterns:**
- Uses `tokio::spawn` to run channel listeners concurrently.
- Uses `tokio::select!` for the main event loop to handle both messages and shutdown signals.
- Scheduler and heartbeat loops are conditionally spawned based on config.
- All channel and provider operations are awaited.

**Error Handling:**
- If `channel.start()` fails, wraps error in anyhow and returns immediately.
- Channel listener tasks suppress errors silently (logs info if gateway receiver drops).

#### `async fn background_summarizer(store: Store, provider: Arc<dyn Provider>, summarize_prompt: String, facts_prompt: String)`
**Purpose:** Periodically find and summarize idle conversations (infinite background task).

**Parameters:**
- `store: Store` - Shared memory store.
- `provider: Arc<dyn Provider>` - Shared provider reference.
- `summarize_prompt: String` - Prompt template for conversation summarization (from `Prompts.summarize`).
- `facts_prompt: String` - Prompt template for facts extraction (from `Prompts.facts`).

**Returns:** Never returns (infinite loop).

**Logic:**
1. Loop forever with 60-second sleep between iterations.
2. Call `store.find_idle_conversations()` to find conversations inactive for a threshold period.
3. For each idle conversation:
   - Call `summarize_conversation()` to summarize and close it.
   - Log errors but continue processing other conversations.
4. Log errors from `find_idle_conversations()` but continue the loop.

**Async Patterns:**
- Uses `tokio::time::sleep()` for periodic ticking.
- All storage and provider operations are awaited.

**Error Handling:**
- Errors are logged with `error!()` but do not stop the task.
- Task runs indefinitely regardless of errors.

#### `async fn scheduler_loop(store: Store, channels: HashMap<String, Arc<dyn Channel>>, poll_secs: u64)`
**Purpose:** Background task that periodically checks for due scheduled tasks and delivers them via the appropriate channel.

**Parameters:**
- `store: Store` - Shared memory store for task queries.
- `channels: HashMap<String, Arc<dyn Channel>>` - Map of channel implementations for delivery.
- `poll_secs: u64` - Polling interval in seconds (from `SchedulerConfig.poll_interval_secs`).

**Returns:** Never returns (infinite loop).

**Logic:**
1. Loop forever with `poll_secs`-second sleep between iterations.
2. Call `store.get_due_tasks()` to find tasks where `status = 'pending'` and `due_at <= now`.
3. For each due task `(id, channel_name, reply_target, description, repeat)`:
   - Build an `OutgoingMessage` with text `"Reminder: {description}"` and `reply_target`.
   - Look up the channel by `channel_name` in the channels map.
   - If channel not found, log warning and skip.
   - Send the message via `channel.send()`.
   - If send fails, log error and skip to next task.
   - Call `store.complete_task(id, repeat)` to mark task as delivered (one-shot) or advance `due_at` (recurring).
   - Log success.
4. Log errors from `get_due_tasks()` but continue the loop.

**Async Patterns:**
- Uses `tokio::time::sleep()` for periodic ticking.
- All storage and channel operations are awaited.

**Error Handling:**
- Channel send errors are logged and the task is skipped (not marked complete).
- Task completion errors are logged but do not stop the loop.
- `get_due_tasks()` errors are logged but do not stop the loop.

#### `async fn heartbeat_loop(provider: Arc<dyn Provider>, channels: HashMap<String, Arc<dyn Channel>>, config: HeartbeatConfig, heartbeat_checklist_prompt: String, memory: Store)`
**Purpose:** Background task that periodically invokes the AI provider for a context-aware health check-in. Skips the API call entirely when no checklist is configured. If the provider reports an issue, the alert is delivered via a configured channel. If everything is fine (response contains `HEARTBEAT_OK`), the response is suppressed.

**Parameters:**
- `provider: Arc<dyn Provider>` - Shared provider reference for the check-in call.
- `channels: HashMap<String, Arc<dyn Channel>>` - Map of channel implementations for alert delivery.
- `config: HeartbeatConfig` - Heartbeat configuration (interval, active hours, channel, reply target).
- `heartbeat_checklist_prompt: String` - Prompt template with `{checklist}` placeholder (from `Prompts.heartbeat_checklist`).
- `memory: Store` - Shared memory store for enriching heartbeat context with user facts and recent summaries.

**Returns:** Never returns (infinite loop).

**Logic:**
1. Loop forever with `config.interval_minutes * 60` second sleep between iterations.
2. Check active hours:
   - If both `active_start` and `active_end` are non-empty, call `is_within_active_hours()`.
   - If outside active hours, log info and skip this iteration.
3. Read checklist from `~/.omega/HEARTBEAT.md` via `read_heartbeat_file()`.
4. **Skip when no checklist**: If `read_heartbeat_file()` returns `None`, log info and skip this iteration entirely (no API call).
5. Build prompt from `heartbeat_checklist_prompt` with `{checklist}` replaced by the file content.
6. **Context enrichment**: Enrich the prompt with memory data:
   - Call `memory.get_all_facts()` — if non-empty, append "Known about the user:" followed by key-value pairs.
   - Call `memory.get_all_recent_summaries(3)` — if non-empty, append "Recent activity:" followed by timestamped summaries.
7. Call `provider.complete()` with the enriched prompt context.
8. On success:
   - Strip markdown formatting characters (`*`, `` ` ``) from the response before checking for `HEARTBEAT_OK`.
   - If cleaned response contains `HEARTBEAT_OK`, log info and suppress (no message sent).
   - Otherwise, send the response as an alert via `config.channel` to `config.reply_target`.
   - If channel not found, log warning.
9. On provider error, log error.

**Async Patterns:**
- Uses `tokio::time::sleep()` for periodic ticking.
- Provider and channel operations are awaited.

**Error Handling:**
- Provider errors are logged but do not stop the loop.
- Channel send errors are logged but do not stop the loop.
- Missing channel is logged as warning.

#### `async fn summarize_conversation(store: &Store, provider: &Arc<dyn Provider>, conversation_id: &str, summarize_prompt: &str, facts_prompt_template: &str) -> Result<(), anyhow::Error>`
**Purpose:** Summarize a conversation, extract user facts, and close it.

**Parameters:**
- `store: &Store` - Reference to the memory store.
- `provider: &Arc<dyn Provider>` - Reference to the AI provider.
- `conversation_id: &str` - ID of the conversation to summarize.
- `summarize_prompt: &str` - Prompt for conversation summarization (from `Prompts.summarize`).
- `facts_prompt_template: &str` - Prompt for facts extraction (from `Prompts.facts`).

**Returns:** `Result<(), anyhow::Error>`.

**Logic:**
1. Fetch all messages from the conversation via `store.get_conversation_messages()`.
2. If empty, close the conversation with "(empty conversation)" summary and return Ok.
3. Build a plain-text transcript by iterating messages and formatting as "User: ..." or "Assistant: ...".
4. **Summarization step:**
   - Create prompt by concatenating `summarize_prompt` + "\n\n" + transcript.
   - Call `provider.complete(Context::new(prompt))`.
   - On success, use the response text as summary.
   - On failure, use fallback: "({count} messages, summary unavailable)".
5. **Facts extraction step:**
   - Create prompt by concatenating `facts_prompt_template` + "\n\n" + transcript.
   - Call `provider.complete(Context::new(prompt))`.
   - Parse response line by line as "key: value" pairs.
   - For each valid pair (non-empty key and value), call `store.store_fact(sender_id, key, value)`.
   - If response is "none", skip fact storage.
6. Query the database directly via `sqlx::query_as()` to get the `sender_id` from the conversations table.
7. Call `store.close_conversation(conversation_id, summary)` to mark conversation as closed and store summary.
8. Log success.
9. Return Ok(()).

**Async Patterns:**
- Uses `provider.complete()` twice in sequence (summarization, then facts).
- Uses `sqlx::query_as()` directly for database queries.
- All operations are awaited.

**Error Handling:**
- Early return on `get_conversation_messages()` failure.
- Summarization failure falls back to message count.
- Facts extraction errors are caught with `if let Ok()` and skipped.
- Database query errors are suppressed via `.ok().flatten()`.
- Returns top-level error on `close_conversation()` failure.

#### `async fn shutdown(&self, bg_handle: &JoinHandle<()>, sched_handle: &Option<JoinHandle<()>>, hb_handle: &Option<JoinHandle<()>>)`
**Purpose:** Gracefully shut down the gateway.

**Parameters:**
- `bg_handle: &tokio::task::JoinHandle<()>` - Handle to the background summarizer task.
- `sched_handle: &Option<tokio::task::JoinHandle<()>>` - Optional handle to the scheduler loop task.
- `hb_handle: &Option<tokio::task::JoinHandle<()>>` - Optional handle to the heartbeat loop task.

**Returns:** None (void).

**Logic:**
1. Log "Shutting down...".
2. Abort the background summarizer task via `bg_handle.abort()`.
3. If `sched_handle` is `Some`, abort the scheduler task.
4. If `hb_handle` is `Some`, abort the heartbeat task.
5. Find all active conversations via `store.find_all_active_conversations()`.
6. For each active conversation, call `summarize_conversation()` to summarize before closing.
7. Log warnings for summarization errors but continue.
8. For each channel, call `channel.stop()` to cleanly shut down the channel.
9. Log warnings for channel stop errors but continue.
10. Log "Shutdown complete.".

**Error Handling:**
- Errors are logged with `warn!()` but do not stop the shutdown process.
- All channels are stopped regardless of individual failures.

#### `async fn handle_message(&self, incoming: IncomingMessage)`
**Purpose:** Process a single incoming message through the complete pipeline.

**Parameters:**
- `incoming: IncomingMessage` - The message to process.

**Returns:** None (void, logging errors).

**Pipeline Stages:**

**Stage 1: Auth Check (Lines 262-292)**
- If auth is enabled, call `check_auth()`.
- If denied, log warning, audit the denial, send deny message, and return.
- Audit status: `AuditStatus::Denied`.
- Does not process message further.

**Stage 2: Input Sanitization (Lines 294-305)**
- Call `sanitize::sanitize(&incoming.text)`.
- If modified, log warning with sanitization warnings.
- Clone the incoming message and replace its text with sanitized version.

**Stage 3: Command Dispatch (Lines 307-320)**
- Call `commands::Command::parse()` to check if input is a bot command.
- If command detected:
  - Call `commands::handle()` to process the command.
  - Send response text.
  - Return (skip provider call).
- Examples: `/uptime`, `/help`, `/status`.

**Stage 3b: Platform Formatting Hint**
- After command dispatch, inject a platform-specific formatting hint into the system prompt:
  - **WhatsApp**: "Platform: WhatsApp. Avoid markdown tables and headers — use bold (*text*) and bullet lists instead."
  - **Telegram**: "Platform: Telegram. Markdown is supported (bold, italic, code blocks)."
  - Other channels: no hint injected.
- This hint is appended to the system prompt before context building.

**Stage 3c: Group Chat Rules Injection**
- If `incoming.is_group` is `true`, append group-specific rules to the system prompt:
  - Only respond when directly mentioned by name, asked a question, or adding genuine value.
  - Do not leak personal facts from private conversations.
  - If the message does not warrant a response, reply with exactly `SILENT`.

**Stage 4: Typing Indicator (Lines 322-342)**
- Get the channel for the incoming message.
- If channel exists and incoming has a `reply_target`, spawn a repeating task:
  - Send initial typing action immediately.
  - Every 5 seconds, resend typing action.
  - Abort if channel send fails.
- Store handle for later abort.

**Stage 4b: Project Instruction Injection**
- Calls `self.memory.get_fact(&incoming.sender_id, "active_project")` to check for an active project.
- If an active project is found, calls `omega_skills::get_project_instructions(&self.projects, &project_name)`.
- If instructions are found, prepends them to the base system prompt with a `---` separator.
- The enriched system prompt is passed to `memory.build_context()`.

**Stage 4c: Heartbeat Awareness**
- After project instruction injection, calls `read_heartbeat_file()`.
- If a heartbeat checklist exists, appends its contents to the system prompt under a "Current heartbeat checklist" header.
- This gives the provider awareness of what items are already being monitored, enabling it to avoid duplicates and to confirm removals.

**Stage 4d: Sandbox Prompt Injection**
- If `self.sandbox_prompt` is `Some(constraint)`, prepends the sandbox constraint text to the system prompt.
- This injects mode-specific instructions (e.g., "You are running in SANDBOX mode. Only operate within the workspace directory..." for sandbox mode, or "You are running in READ-ONLY mode..." for rx mode).
- In `rwx` mode, `sandbox_prompt` is `None` and no constraint is injected.

**Stage 5: Build Context from Memory (Lines 344-356)**
- Call `self.memory.build_context(&clean_incoming, &self.prompts.system)` to build enriched context (using the potentially project-enriched system prompt).
- This includes recent conversation history, relevant facts, and system prompt.
- If error, abort typing task, send error message, and return.

**Stage 5b: MCP Trigger Matching**
- Call `omega_skills::match_skill_triggers(&self.skills, &clean_incoming.text)` to check if the message matches any skill triggers.
- If matched, populate `context.mcp_servers` with the declared MCP servers from matching skills.
- The provider will use these to write temporary `.claude/settings.local.json` and add `mcp__<name>__*` to `--allowedTools`.

**Stage 6: Get Response from Provider (async with delayed, localized status updates)**
- Resolve the user's `preferred_language` fact from memory (defaults to English).
- Get localized status messages via `status_messages(lang)`.
- Spawn `provider.complete(&context)` as a background task via `tokio::spawn`.
- Spawn a delayed status updater task: sends a localized first nudge after 15 seconds, then localized "Still working..." every 120 seconds. If the provider responds within 15 seconds, the updater is aborted and the user sees no extra messages.
- Wait for the provider result; abort the status updater when the result arrives.
- Map provider errors to user-friendly messages via `friendly_provider_error()`:
  - On timeout -> "I took too long to respond. Please try again..."
  - On other errors -> "Something went wrong. Please try again."
  - On JoinError (task panic) -> "Something went wrong. Please try again."
- On success, set `reply_target` from incoming message.
- On error:
  - Abort typing task.
  - Audit the error with status `AuditStatus::Error`.
  - Send friendly error message.
  - Return.

**Stage 5a: SILENT Response Suppression (Group Chats)**
- After receiving the provider response and aborting the typing indicator:
- If `incoming.is_group` is `true` AND `response.text.trim()` equals `"SILENT"`:
  - Log info about the suppression.
  - Return immediately (skip storage, audit, and sending).
  - This prevents the bot from sending empty or unwanted responses in group chats.

**Stage 5b: SCHEDULE Marker Extraction**
- After SILENT suppression check:
- Call `extract_schedule_marker(&response.text)` to find a `SCHEDULE:` line.
- If found, call `parse_schedule_line()` to extract `(description, due_at, repeat)`.
- If parsing succeeds:
  - Map `repeat = "once"` to `None`, otherwise `Some(repeat)`.
  - Call `self.memory.create_task()` with channel, sender_id, reply_target, description, due_at, repeat.
  - Log the created task ID on success, or log error on failure.
- Call `strip_schedule_marker(&response.text)` to remove the `SCHEDULE:` line from the response before sending to the user.

**Stage 5c: LANG_SWITCH Marker Extraction**
- After SCHEDULE extraction:
- Call `extract_lang_switch(&response.text)` to find a `LANG_SWITCH:` line.
- If found:
  - Call `self.memory.store_fact(&incoming.sender_id, "preferred_language", &lang)` to persist the language change.
  - Log the language switch on success, or log error on failure.
  - Call `strip_lang_switch(&response.text)` to remove the `LANG_SWITCH:` line from the response before sending to the user.

**Stage 5d: HEARTBEAT_ADD / HEARTBEAT_REMOVE Marker Extraction**
- After LANG_SWITCH extraction:
- Call `extract_heartbeat_markers(&response.text)` to find all `HEARTBEAT_ADD:` and `HEARTBEAT_REMOVE:` lines.
- If any markers found:
  - Call `apply_heartbeat_changes(&actions)` to update `~/.omega/HEARTBEAT.md`.
  - Log each add/remove action at INFO level.
  - Call `strip_heartbeat_markers(&response.text)` to remove all marker lines from the response before sending to the user.

**Stage 6: Store Exchange in Memory (Lines 579-582)**
- Call `self.memory.store_exchange(&incoming, &response)` to save the exchange.
- Log error if storage fails but continue.

**Stage 7: Audit Log (Lines 584-599)**
- Log the successful exchange via `self.audit.log()`.
- Include all metadata: provider, model, processing time.
- Status: `AuditStatus::Ok`.

**Stage 8: Send Response (Lines 601-608)**
- Get the channel for the incoming message.
- Call `channel.send(response)` to deliver the response.
- Log error if channel send fails.

**Async Patterns:**
- All stages are awaited sequentially.
- Typing task runs concurrently via `tokio::spawn()`.
- Task is aborted early if error occurs before response.

**Error Handling:**
- Auth failure: deny message sent, audit logged, early return.
- Sanitization warnings: logged but processing continues.
- Context build failure: error message sent, early return.
- Provider error: error message sent, audit logged, early return.
- Memory storage failure: logged but does not stop response delivery.
- Channel send failure: logged but pipeline completes.

#### `fn check_auth(&self, incoming: &IncomingMessage) -> Option<String>`
**Purpose:** Verify if a message sender is authorized.

**Parameters:**
- `incoming: &IncomingMessage` - The incoming message to check.

**Returns:** `Option<String>` where `None` = allowed, `Some(reason)` = denied.

**Logic:**
1. Match on `incoming.channel`:
   - **"telegram"**:
     - Get `allowed_users` list from `channel_config.telegram`.
     - If list is empty, allow all (returns `None`). Used for testing.
     - If list exists:
       - Parse `incoming.sender_id` as i64 (default to -1 on parse error).
       - If sender_id is in allowed_users, return `None`.
       - Otherwise, return `Some("telegram user X not in allowed_users")`.
     - If telegram config not set, return `Some("telegram channel not configured")`.
   - **Other channels**:
     - Return `Some("unknown channel: {name}")`.

**Error Handling:**
- Parsing sender_id as i64 uses `unwrap_or(-1)` (will never match valid user, causing denial).
- No panics.

#### `async fn send_text(&self, incoming: &IncomingMessage, text: &str)`
**Purpose:** Send a plain text response message.

**Parameters:**
- `incoming: &IncomingMessage` - The original incoming message (used for channel and reply target).
- `text: &str` - The text to send.

**Returns:** None (void).

**Logic:**
1. Create an `OutgoingMessage` with:
   - `text: text.to_string()`.
   - `metadata: MessageMetadata::default()`.
   - `reply_target: incoming.reply_target.clone()`.
2. Get the channel for `incoming.channel`.
3. Call `channel.send(msg)`.
4. Log error if send fails.

**Error Handling:**
- Send errors are logged but do not return an error code.

## Free Functions (Module-Level Helpers)

### `fn extract_schedule_marker(text: &str) -> Option<String>`
**Purpose:** Extract the first `SCHEDULE:` line from response text.

**Logic:** Iterates through lines, finds the first line whose trimmed form starts with `"SCHEDULE:"`, returns it trimmed.

**Returns:** `Some(line)` if found, `None` otherwise.

### `fn parse_schedule_line(line: &str) -> Option<(String, String, String)>`
**Purpose:** Parse a `SCHEDULE:` line into `(description, due_at, repeat)`.

**Format:** `SCHEDULE: <description> | <ISO 8601 datetime> | <once|daily|weekly|monthly|weekdays>`

**Logic:**
1. Strip `"SCHEDULE:"` prefix.
2. Split on `|` into exactly 3 parts.
3. Trim each part.
4. Validate that description and due_at are non-empty.
5. Lowercase the repeat value.
6. Return the tuple.

**Returns:** `None` if format is invalid (wrong number of parts or empty fields).

### `fn strip_schedule_marker(text: &str) -> String`
**Purpose:** Remove all `SCHEDULE:` lines from response text so the marker is not shown to the user.

**Logic:** Filters out any line whose trimmed form starts with `"SCHEDULE:"`, then joins remaining lines and trims the result.

### `fn extract_lang_switch(text: &str) -> Option<String>`
**Purpose:** Extract the language name from a `LANG_SWITCH:` line in response text.

**Logic:** Iterates through lines, finds the first line whose trimmed form starts with `"LANG_SWITCH:"`, strips the prefix, trims, and returns the language name. Returns `None` if not found or if language is empty.

### `fn strip_lang_switch(text: &str) -> String`
**Purpose:** Remove all `LANG_SWITCH:` lines from response text so the marker is not shown to the user.

**Logic:** Filters out any line whose trimmed form starts with `"LANG_SWITCH:"`, then joins remaining lines and trims the result.

### `fn read_heartbeat_file() -> Option<String>`
**Purpose:** Read `~/.omega/HEARTBEAT.md` if it exists, for use as a heartbeat checklist.

**Logic:**
1. Get `$HOME` env var.
2. Read `{home}/.omega/HEARTBEAT.md`.
3. Return `None` if file does not exist, is unreadable, or has only whitespace.
4. Return `Some(content)` otherwise.

### `enum HeartbeatAction`
**Purpose:** Represents an action extracted from a `HEARTBEAT_ADD:` or `HEARTBEAT_REMOVE:` marker.

**Variants:**
- `Add(String)` — Item to add to the heartbeat checklist.
- `Remove(String)` — Keyword to match and remove from the heartbeat checklist.

### `fn extract_heartbeat_markers(text: &str) -> Vec<HeartbeatAction>`
**Purpose:** Extract all `HEARTBEAT_ADD:` and `HEARTBEAT_REMOVE:` markers from response text.

**Logic:** Iterates through lines, finds lines whose trimmed form starts with `"HEARTBEAT_ADD:"` or `"HEARTBEAT_REMOVE:"`, strips the prefix, trims, and collects into a `Vec<HeartbeatAction>`. Empty items (marker with no description) are skipped.

### `fn strip_heartbeat_markers(text: &str) -> String`
**Purpose:** Remove all `HEARTBEAT_ADD:` and `HEARTBEAT_REMOVE:` lines from response text so the markers are not shown to the user.

**Logic:** Filters out any line whose trimmed form starts with `"HEARTBEAT_ADD:"` or `"HEARTBEAT_REMOVE:"`, then joins remaining lines and trims the result.

### `fn apply_heartbeat_changes(actions: &[HeartbeatAction])`
**Purpose:** Apply heartbeat add/remove actions to `~/.omega/HEARTBEAT.md`.

**Logic:**
1. Get `$HOME` env var. Return silently if not set.
2. Read existing file lines (or start with empty vec if file does not exist).
3. For each `Add(item)`: check if item already exists (case-insensitive, ignoring `- ` prefix). If not, append `- {item}`.
4. For each `Remove(item)`: remove all non-comment lines whose content contains the item (case-insensitive partial match). Comment lines (starting with `#`) are never removed.
5. Ensure `~/.omega/` directory exists.
6. Write the updated lines back to the file.

### `fn status_messages(lang: &str) -> (&'static str, &'static str)`
**Purpose:** Return localized status messages for the delayed provider nudge.

**Parameters:**
- `lang: &str` - Language name (e.g., "English", "Spanish").

**Returns:** Tuple of `(first_nudge, still_working)` static strings.

**Logic:** Match on language name. Supports English, Spanish, Portuguese, French, German, Italian, Dutch, Russian. Unknown languages fall back to English.

### `fn friendly_provider_error(raw: &str) -> String`
**Purpose:** Map raw provider error messages to user-friendly messages.

**Parameters:**
- `raw: &str` - The raw error message from the provider or task join error.

**Returns:** `String` - A friendly, user-facing error message.

**Logic:**
1. If `raw` contains "timed out" or similar timeout indicators, return "I took too long to respond. Please try again..."
2. Otherwise, return "Something went wrong. Please try again."

### `fn is_within_active_hours(start: &str, end: &str) -> bool`
**Purpose:** Check if the current local time is within the active hours window.

**Parameters:**
- `start: &str` - Start time in `"HH:MM"` format.
- `end: &str` - End time in `"HH:MM"` format.

**Logic:**
1. Get current local time as `"HH:MM"` string via `chrono::Local::now()`.
2. If `start <= end` (normal range, e.g., `"08:00"` to `"22:00"`): return `now >= start && now < end`.
3. If `start > end` (midnight wrap, e.g., `"22:00"` to `"06:00"`): return `now >= start || now < end`.

**Dependencies:** `chrono` crate for local time formatting.

## Message Flow Diagram

```
[Telegram/WhatsApp] → [Channel Receiver] → [MPSC Channel]
                                               ↓
                                        [Gateway Event Loop]
                                               ↓
                                          [handle_message()]
                                               ↓
                    ┌──────────────────────────┼──────────────────────────┐
                    ↓                          ↓                          ↓
            [1. Auth Check]         [2. Sanitize]            [3. Command?]
                    ↓                          ↓                          ↓
              [ALLOWED?]              [Clean Text]          [Yes] → [Handle Cmd]
              /        \                      ↓                      [Send Response]
          [No]        [Yes]          [4. Typing Indicator]          [Return]
            ↓            ↓                      ↓
        [Deny]      [Continue]         [Spawn Repeat Task]
         [Audit]         ↓                     ↓
        [Send Msg]   [5. Build Context]     [Continue]
        [Return]          ↓                     ↓
                    [With History + Facts] [5a. Provider.complete()]
                           ↓                   ↓
                      [Enriched CTX]    [Get Response/Error]
                           ↓                   ↓
                           └───────────────────┤
                                               ↓
                                          [Error?]
                                          /      \
                                      [Yes]     [No]
                                        ↓         ↓
                                    [Send Err] [Abort Typing]
                                    [Audit Err]    ↓
                                    [Abort Type]  [5b. Extract SCHEDULE:]
                                    [Return]       ↓
                                            [create_task() if marker]
                                            [strip marker from response]
                                                   ↓
                                            [6. Store Exchange]
                                                   ↓
                                            [7. Audit Log (Success)]
                                                   ↓
                                            [8. Send Response]
                                                   ↓
                                                [Done]

--- Background Tasks ---

[Scheduler Loop]   ←── polls every poll_interval_secs
       ↓
  get_due_tasks()
       ↓
  [For each due task] → channel.send("Reminder: ...")
       ↓                       ↓
  complete_task()         [Advance due_at for recurring]

[Heartbeat Loop]   ←── polls every interval_minutes * 60s
       ↓
  is_within_active_hours()
       ↓ (if active)
  read_heartbeat_file()
       ↓ (None → skip, no API call)
  enrich prompt with memory.get_all_facts() + memory.get_all_recent_summaries(3)
       ↓
  provider.complete(enriched heartbeat prompt)
       ↓
  [HEARTBEAT_OK?] → suppress / [Alert?] → channel.send(alert)
```

## Error Handling Strategy

### Error Propagation Levels

1. **Critical Errors (Early Return):**
   - Channel startup failure → breaks gateway initialization.
   - Auth denial → deny message sent, audit logged, message dropped.
   - Context build failure → error message sent, message dropped.
   - Provider error → error message sent, audit logged, message dropped.

2. **Non-Critical Errors (Log and Continue):**
   - Memory store errors → logged, response still sent if provider succeeded.
   - Audit logging errors → logged, processing continues.
   - Channel send errors → logged, does not block completion.
   - Background summarization errors → logged, loop continues.
   - Idle conversation query errors → logged, loop continues.

3. **Error Auditing:**
   - All auth denials are logged with `AuditStatus::Denied`.
   - All provider errors are logged with `AuditStatus::Error`.
   - All successful exchanges are logged with `AuditStatus::Ok`.

### Error Types Used
- `anyhow::anyhow!()` for wrapping errors in run().
- `anyhow::Error` for Result types.
- `sqlx` errors from database operations (caught with `.ok().flatten()`).
- Tracing logs: `error!()`, `warn!()`, `info!()`.

## Async Runtime Patterns

### Concurrency Model
- **Single main thread:** The gateway runs on a single tokio runtime thread.
- **Multiple channels:** Each channel listener runs in its own `tokio::spawn()` task.
- **Background summarizer:** Runs in a dedicated `tokio::spawn()` task.
- **Scheduler loop:** Conditionally runs in a dedicated `tokio::spawn()` task (when `scheduler_config.enabled`).
- **Heartbeat loop:** Conditionally runs in a dedicated `tokio::spawn()` task (when `heartbeat_config.enabled`).
- **Typing repeater:** For each message, a separate `tokio::spawn()` task repeats typing every 5 seconds.
- **Provider task:** For each message, `provider.complete()` is spawned via `tokio::spawn()` to run in the background.
- **Status updater:** For each message, a delayed status updater task is spawned that sends a localized first nudge after 15 seconds, then periodic localized "Still working..." messages every 120 seconds; aborted when the provider result arrives. If the provider responds within 15 seconds, no status message is sent. Messages are localized to the user's `preferred_language` fact via `status_messages()`.

### Synchronization
- **MPSC Channel:** All incoming messages from channels are collected on a single 256-capacity mpsc queue.
- **Arc Sharing:** Provider and channels are shared via `Arc` for thread-safe access.
- **No Locks:** The gateway does not use Mutex or RwLock; all access is single-threaded except for shared Arc references.

### Shutdown Coordination
- **Signal handling:** `tokio::signal::ctrl_c()` breaks the main loop.
- **Task abortion:** Background summarizer is aborted via `bg_handle.abort()`. Scheduler and heartbeat handles are aborted if present.
- **Channel stopping:** Each channel's `stop()` method is called.
- **Graceful conversation closure:** All active conversations are summarized before shutdown completes.

## Channel Integration

### Channel Trait Requirements
- **`start() -> Result<mpsc::Receiver<IncomingMessage>>`:** Returns a receiver for messages from that channel. Must be called once at gateway startup.
- **`send(OutgoingMessage) -> Result<()>`:** Sends a message back to the user.
- **`send_typing(target) -> Result<()>`:** Sends a typing indicator. Called repeatedly every 5 seconds.
- **`stop() -> Result<()>`:** Cleanly shuts down the channel.

### Telegram Integration Details
- Auth is enforced via `channel_config.telegram.allowed_users` list.
- Empty list allows all users (for testing).
- Non-empty list restricts to specified user IDs.
- `sender_id` is parsed as i64.

## Provider Integration

### Provider Trait Requirements
- **`name() -> &'static str`:** Returns the provider name (e.g., "Claude Code CLI").
- **`complete(Context) -> Result<Response>`:** Takes a context with full prompt and returns a response.

### Response Metadata
The response includes:
- `text: String` - The assistant's reply.
- `metadata.provider_used: String` - Name of the provider (e.g., "Claude Code CLI").
- `metadata.model: Option<String>` - Model name (e.g., "claude-opus-4-6").
- `metadata.processing_time_ms: u32` - Time taken by the provider.
- `reply_target: Option<String>` - Set to incoming message's reply_target for threading.

## Memory Integration

### Store Operations Used
- **`build_context(&IncomingMessage, &str) -> Result<Context>`:** Builds enriched context with history and facts, using the provided base system prompt.
- **`store_exchange(&IncomingMessage, &OutgoingMessage) -> Result<()>`:** Saves the message pair to conversation history.
- **`store_fact(&sender_id, &key, &value) -> Result<()>`:** Stores an extracted fact about a user.
- **`get_conversation_messages(&conversation_id) -> Result<Vec<(String, String)>>`:** Fetches all messages in a conversation.
- **`close_conversation(&conversation_id, &summary) -> Result<()>`:** Marks a conversation as closed with a summary.
- **`find_idle_conversations() -> Result<Vec<(String, String, String)>>`:** Finds conversations inactive for a threshold.
- **`find_all_active_conversations() -> Result<Vec<(String, String, String)>>`:** Finds all currently active conversations.
- **`pool() -> &SqlitePool`:** Provides direct database access for queries.
- **`create_task(&channel, &sender_id, &reply_target, &description, &due_at, repeat) -> Result<String>`:** Creates a scheduled task. Called from handle_message Stage 5b.
- **`get_due_tasks() -> Result<Vec<(String, String, String, String, Option<String>)>>`:** Fetches tasks where status is pending and due_at <= now. Called by scheduler_loop.
- **`complete_task(&id, repeat) -> Result<()>`:** Marks a one-shot task as delivered or advances due_at for recurring tasks. Called by scheduler_loop.
- **`get_all_facts() -> Result<Vec<(String, String)>>`:** Gets all facts across all users (excluding `welcomed`). Called by heartbeat_loop for context enrichment.
- **`get_all_recent_summaries(limit) -> Result<Vec<(String, String)>>`:** Gets recent conversation summaries across all users. Called by heartbeat_loop with `limit = 3` for context enrichment.

## Configuration Parameters

### AuthConfig
- `enabled: bool` - Whether authentication is enforced.
- `deny_message: String` - Message to send when auth fails.

### ChannelConfig
- `telegram: Option<TelegramConfig>` - Telegram-specific settings.
  - `allowed_users: Vec<i64>` - Whitelist of user IDs. Empty = allow all.

### HeartbeatConfig
- `enabled: bool` - Whether the heartbeat loop is spawned.
- `interval_minutes: u64` - Minutes between heartbeat checks (default: 30).
- `active_start: String` - Start of active hours window (`"HH:MM"` format). Empty = always active.
- `active_end: String` - End of active hours window (`"HH:MM"` format). Empty = always active.
- `channel: String` - Channel name for alert delivery (e.g., `"telegram"`).
- `reply_target: String` - Platform-specific delivery target (e.g., chat ID).

### SchedulerConfig
- `enabled: bool` - Whether the scheduler loop is spawned (default: true).
- `poll_interval_secs: u64` - Seconds between scheduler polls (default: 60).

## Logging and Observability

### Log Levels Used
- **INFO:** Gateway startup, channel starts, message previews, conversation summaries, shutdown.
- **WARN:** Auth denials, sanitization warnings, shutdown summarization errors, channel stop errors, conversation summarization errors.
- **ERROR:** Context build failures, provider errors, memory storage errors, channel send errors, idle conversation query errors.

### Audit Logging
All interactions are logged to SQLite with:
- Channel name, sender_id, sender_name.
- Input text and output text.
- Provider name and model.
- Processing time in milliseconds.
- Status (Ok, Denied, Error).
- Denial reason (if denied).

## Security Considerations

1. **Input Sanitization:** All user input is sanitized before reaching the provider to neutralize injection patterns.
2. **Auth Enforcement:** Access control is enforced before any processing begins.
3. **Audit Trail:** All interactions are logged for security review.
4. **No Secrets in Logs:** User text is logged but no API keys or credentials are logged.
5. **Error Suppression:** Detailed errors are logged but user-facing messages are generic to avoid info leaks.

## Performance Characteristics

- **Single-threaded Gateway:** All message processing happens sequentially on the main thread.
- **Concurrent Channels:** Multiple channels can deliver messages concurrently via tokio tasks.
- **Background Summarization:** Idle conversation summarization happens every 60 seconds without blocking the main loop.
- **MPSC Buffering:** Up to 256 incoming messages can be buffered while waiting for processing.

## Dependencies

### External Crates
- `anyhow` - Error handling.
- `tokio` - Async runtime, synchronization primitives.
- `tracing` - Structured logging.
- `sqlx` - Database queries (via Store).
- `chrono` - Local time formatting for active hours check.

### Internal Dependencies
- `omega_core` - Core types, traits, config (including `Prompts`), sanitization.
- `omega_memory` - Store, AuditLogger, AuditEntry, AuditStatus.
- `crate::commands` - Command parsing and handling.

## Invariants

1. Only one task in the main event loop at a time (tokio::select!).
2. All channels are started before the main loop.
3. The background summarizer is spawned and never joined (infinite loop).
4. Auth is checked before any message processing.
5. Sanitization happens before command dispatch and provider call.
6. Response is sent to the channel that received the message.
7. All exchanges are stored in memory before audit logging.
8. Typing indicator is aborted when response is sent or on error.
9. On shutdown, all active conversations are summarized, all background tasks are aborted, and all channels are stopped.
10. SCHEDULE: markers are stripped from the response before sending to the user.
11. LANG_SWITCH: markers are stripped from the response before sending to the user. The extracted language is persisted as a `preferred_language` fact.
12. Scheduler loop only runs when `scheduler_config.enabled` is true.
13. Heartbeat loop only runs when `heartbeat_config.enabled` is true.
14. Heartbeat alerts are suppressed when the provider response contains `HEARTBEAT_OK` (after stripping markdown formatting).
15. Status updater is aborted when provider result arrives.
16. When `is_group` is true and the provider response is `SILENT`, the response is suppressed (not stored, not audited, not sent).
17. Platform formatting hints are injected into the system prompt based on `incoming.channel` (WhatsApp avoids markdown tables/headers; Telegram supports full markdown).
18. Group chat rules are injected into the system prompt when `incoming.is_group` is `true`.
19. Heartbeat loop skips API calls entirely when no checklist file (`~/.omega/HEARTBEAT.md`) is configured.
20. Heartbeat prompt is enriched with user facts and recent conversation summaries from memory.
21. HEARTBEAT_ADD: and HEARTBEAT_REMOVE: markers are stripped from the response before sending to the user. Adds are appended to `~/.omega/HEARTBEAT.md`; removes use case-insensitive partial matching and never remove comment lines.
22. The current heartbeat checklist is injected into the system prompt so the provider knows what is already monitored.
23. When `sandbox_prompt` is `Some`, the sandbox constraint text is prepended to the system prompt before context building.
24. The startup log includes the active sandbox mode for operational visibility.

## Tests

### `test_friendly_provider_error_timeout`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `friendly_provider_error()` returns the timeout-specific friendly message when the raw error string contains a timeout indicator.

### `test_friendly_provider_error_generic`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `friendly_provider_error()` returns the generic friendly message ("Something went wrong. Please try again.") when the raw error string does not contain a timeout indicator.

### `test_status_messages_all_languages`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `status_messages()` returns non-empty nudge and still-working strings for all 8 supported languages.

### `test_status_messages_unknown_falls_back_to_english`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `status_messages()` falls back to English for unrecognized language names.

### `test_status_messages_spanish`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `status_messages("Spanish")` returns Spanish-language status messages.

### `test_read_heartbeat_file_returns_none_when_missing`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `read_heartbeat_file()` returns `None` when `~/.omega/HEARTBEAT.md` does not exist or is empty, confirming the skip-when-no-checklist behavior.

### `test_bundled_system_prompt_contains_soul`

**Type:** Synchronous unit test (`#[test]`)

Verifies that the bundled `SYSTEM_PROMPT.md` (via `include_str!`) contains the Soul personality section with key phrases like "genuinely helpful" and "earn its place".

### `test_bundled_facts_prompt_guided_schema`

**Type:** Synchronous unit test (`#[test]`)

Verifies that the bundled `SYSTEM_PROMPT.md` (via `include_str!`) contains the guided fact-extraction schema with canonical fields like "preferred_name", "pronouns", and "timezone".

### `test_extract_heartbeat_add`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `extract_heartbeat_markers()` correctly extracts a single `HEARTBEAT_ADD:` marker from response text.

### `test_extract_heartbeat_remove`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `extract_heartbeat_markers()` correctly extracts a single `HEARTBEAT_REMOVE:` marker from response text.

### `test_extract_heartbeat_multiple`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `extract_heartbeat_markers()` extracts both `HEARTBEAT_ADD:` and `HEARTBEAT_REMOVE:` markers from the same response text.

### `test_extract_heartbeat_empty_ignored`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `extract_heartbeat_markers()` ignores markers with empty descriptions (e.g., `HEARTBEAT_ADD: ` with trailing whitespace only).

### `test_strip_heartbeat_markers`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `strip_heartbeat_markers()` removes `HEARTBEAT_ADD:` lines from response text while preserving other lines.

### `test_strip_heartbeat_both_types`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `strip_heartbeat_markers()` removes both `HEARTBEAT_ADD:` and `HEARTBEAT_REMOVE:` lines from the same response text.

### `test_apply_heartbeat_add`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `apply_heartbeat_changes()` adds new items to `~/.omega/HEARTBEAT.md`, preserves existing items, and prevents duplicate adds (case-insensitive). Uses a temporary directory with overridden `$HOME`.

### `test_apply_heartbeat_remove`

**Type:** Synchronous unit test (`#[test]`)

Verifies that `apply_heartbeat_changes()` removes matching items from `~/.omega/HEARTBEAT.md` using case-insensitive partial matching, preserves comment lines, and keeps non-matching items. Uses a temporary directory with overridden `$HOME`.
