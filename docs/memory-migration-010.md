# Reward-Based Learning Tables (Migration 010)

## Path

`crates/omega-memory/migrations/010_outcomes.sql`

## What This Migration Does

Migration 010 creates two tables that power OMEGA's reward-based learning system: `outcomes` (short-term working memory) and `lessons` (permanent behavioral rules).

Before this migration, OMEGA had no structured way to learn from interaction outcomes. Skill improvement (`SKILL_IMPROVE` marker) only addressed per-skill errors. The reward-based system provides system-wide behavioral adaptation across any domain.

Now, after every interaction:
- OMEGA evaluates whether its response was helpful (+1), neutral (0), or redundant/annoying (-1)
- Raw outcomes are stored with domain and description for short-term context (24-48h)
- When patterns emerge, OMEGA distills them into permanent behavioral rules (lessons)
- Both outcomes and lessons are injected into every future conversation and heartbeat context

## Migration Sequence

| Order | File | What It Creates |
|-------|------|----------------|
| 5 | `005_scheduled_tasks.sql` | Task queue: `scheduled_tasks` table + indexes |
| 7 | `007_task_type.sql` | Task type: `task_type` column on `scheduled_tasks` |
| 8 | `008_user_aliases.sql` | Cross-channel user aliases: `user_aliases` table |
| 9 | `009_task_retry.sql` | Retry support: `retry_count` + `last_error` columns |
| **10** | **`010_outcomes.sql`** | **Reward-based learning: `outcomes` + `lessons` tables** |

## The Change

```sql
CREATE TABLE IF NOT EXISTS outcomes (
    id        TEXT PRIMARY KEY,
    timestamp TEXT NOT NULL DEFAULT (datetime('now')),
    sender_id TEXT NOT NULL,
    domain    TEXT NOT NULL,
    score     INTEGER NOT NULL CHECK (score IN (-1, 0, 1)),
    lesson    TEXT NOT NULL,
    source    TEXT NOT NULL DEFAULT 'conversation'
);

CREATE INDEX IF NOT EXISTS idx_outcomes_sender_time ON outcomes (sender_id, timestamp);
CREATE INDEX IF NOT EXISTS idx_outcomes_time ON outcomes (timestamp);

CREATE TABLE IF NOT EXISTS lessons (
    id          TEXT PRIMARY KEY,
    sender_id   TEXT NOT NULL,
    domain      TEXT NOT NULL,
    rule        TEXT NOT NULL,
    occurrences INTEGER NOT NULL DEFAULT 1,
    created_at  TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at  TEXT NOT NULL DEFAULT (datetime('now')),
    UNIQUE(sender_id, domain)
);

CREATE INDEX IF NOT EXISTS idx_lessons_sender ON lessons (sender_id);
```

### Table: outcomes

| Column | Type | What It Stores |
|--------|------|---------------|
| `id` | TEXT PRIMARY KEY | UUID v4, generated by the store |
| `timestamp` | TEXT | When the outcome was recorded (ISO 8601, default: now) |
| `sender_id` | TEXT | User this outcome applies to |
| `domain` | TEXT | Domain/topic (e.g., "training", "trading", "health") |
| `score` | INTEGER | +1 helpful, 0 neutral, -1 redundant/annoying. CHECK constraint enforces range. |
| `lesson` | TEXT | What happened (e.g., "User completed calisthenics by 15:00") |
| `source` | TEXT | Where this came from: `'conversation'` or `'heartbeat'` |

Two indexes support the two query patterns:
- `idx_outcomes_sender_time` — per-user queries ordered by time (context building)
- `idx_outcomes_time` — cross-user time-range queries (heartbeat enrichment)

### Table: lessons

| Column | Type | What It Stores |
|--------|------|---------------|
| `id` | TEXT PRIMARY KEY | UUID v4, generated by the store |
| `sender_id` | TEXT | User this lesson applies to |
| `domain` | TEXT | Domain/topic (e.g., "training", "trading") |
| `rule` | TEXT | The behavioral rule (e.g., "User trains Saturday mornings, no need to nag after 12:00") |
| `occurrences` | INTEGER | How many times this pattern has been reinforced (incremented on upsert) |
| `created_at` | TEXT | When the lesson was first created |
| `updated_at` | TEXT | When the lesson was last updated |

The `UNIQUE(sender_id, domain)` constraint enables upsert behavior: storing a lesson with the same domain replaces the rule and increments `occurrences`.

## How the Two Tiers Work Together

```
Interaction happens
    |
    v
OMEGA emits REWARD: +1|training|User completed workout on time
    |
    v
Gateway → store.store_outcome() → outcomes table
    |
    v (over time, patterns emerge)
OMEGA emits LESSON: training|User trains Saturday mornings, no need to nag after 12:00
    |
    v
Gateway → store.store_lesson() → lessons table (upsert, occurrences++)
    |
    v (on every future interaction)
build_context() loads last 15 outcomes + all lessons → injected into system prompt
```

## Context Injection Details

| Context | Outcomes Query | Lessons Query |
|---------|---------------|---------------|
| Regular conversation | `get_recent_outcomes(sender_id, 15)` — last 15 per user | `get_lessons(sender_id)` — all per user |
| Heartbeat enrichment | `get_all_recent_outcomes(24, 20)` — last 24h, all users | `get_all_lessons()` — all users |

Outcomes in conversation context include relative timestamps ("3h ago", "1d ago") via `format_relative_time()` for temporal reasoning. Heartbeat outcomes use raw timestamps.

## Backward Compatibility

Both tables use `CREATE TABLE IF NOT EXISTS`, so re-running the migration is safe. Existing databases gain the new tables without affecting any other data. The context injection is additive — if no outcomes or lessons exist, the system prompt sections are simply omitted.
