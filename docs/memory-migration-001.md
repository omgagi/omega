# Memory Migration 001 -- Initial Schema

## Path

`crates/omega-memory/migrations/001_init.sql`

## Overview

This is the first database migration in Omega's memory system. It creates the three foundational tables that power conversation tracking, message storage, and user fact extraction:

- **`conversations`** -- Groups message exchanges into logical threads per user per channel.
- **`messages`** -- Stores individual user and assistant messages within conversations.
- **`facts`** -- Stores key-value facts about users, extracted from conversations for personalization.

All data is stored in a single SQLite database at `~/.omega/data/memory.db` (configurable via `config.toml`).

## What This Migration Creates

### The `conversations` Table

Every interaction between a user and Omega happens within a conversation. A conversation is scoped to a specific user on a specific channel (e.g., user `123456789` on Telegram). When a user sends a message, the memory store either finds an active conversation for that user/channel pair or creates a new one.

```sql
CREATE TABLE IF NOT EXISTS conversations (
    id          TEXT PRIMARY KEY,
    channel     TEXT NOT NULL,
    sender_id   TEXT NOT NULL,
    started_at  TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at  TEXT NOT NULL DEFAULT (datetime('now'))
);
```

**Key fields:**
- `id` -- A UUID generated by the application. Not auto-incrementing.
- `channel` -- The messaging platform (e.g., `"telegram"`, `"whatsapp"`).
- `sender_id` -- The user's platform-specific ID (stored as text for portability).
- `started_at` / `updated_at` -- UTC timestamps in ISO 8601 format.

**Index:** A composite index on `(channel, sender_id)` speeds up the most common query: "find the active conversation for this user on this channel."

### The `messages` Table

Messages are the core data unit. Every user input and every assistant response is stored as a row in this table, linked to its parent conversation.

```sql
CREATE TABLE IF NOT EXISTS messages (
    id              TEXT PRIMARY KEY,
    conversation_id TEXT NOT NULL REFERENCES conversations(id),
    role            TEXT NOT NULL CHECK (role IN ('user', 'assistant')),
    content         TEXT NOT NULL,
    timestamp       TEXT NOT NULL DEFAULT (datetime('now')),
    metadata_json   TEXT
);
```

**Key fields:**
- `conversation_id` -- Foreign key to `conversations.id`. Links the message to its thread.
- `role` -- Either `'user'` or `'assistant'`. Enforced by a CHECK constraint at the database level.
- `content` -- The message text. For user messages, this is the sanitized input (after prompt injection defense). For assistant messages, this is the AI provider's response.
- `metadata_json` -- Optional JSON blob for provider metadata (model name, processing time, etc.). Nullable because user messages typically have no provider metadata.

**Index:** A composite index on `(conversation_id, timestamp)` supports chronological retrieval of messages within a conversation, which is how context is built for the AI provider.

### The `facts` Table

Facts are key-value pairs extracted from conversations by the AI provider during summarization. They represent things Omega has learned about a user -- name, preferences, timezone, interests, etc.

```sql
CREATE TABLE IF NOT EXISTS facts (
    id                TEXT PRIMARY KEY,
    key               TEXT NOT NULL UNIQUE,
    value             TEXT NOT NULL,
    source_message_id TEXT REFERENCES messages(id),
    created_at        TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at        TEXT NOT NULL DEFAULT (datetime('now'))
);
```

**Key fields:**
- `key` -- The fact identifier (e.g., `"name"`, `"timezone"`, `"preferred_language"`). Globally unique in this version.
- `value` -- The fact content (e.g., `"Alice"`, `"America/Los_Angeles"`).
- `source_message_id` -- Optional reference to the message that produced this fact. Useful for tracing how a fact was derived.

**Important:** This version of the `facts` table has a design limitation -- facts are globally unique by `key`, not scoped per user. This means only one user's name can be stored at a time. Migration 003 fixes this by adding `sender_id` and changing the uniqueness constraint to `UNIQUE(sender_id, key)`.

## Schema Relationships

```
conversations (1) ───< messages (N)
                         |
                         | source_message_id (optional)
                         v
                       facts (N)
```

A conversation contains many messages. A fact may optionally point back to the message it was extracted from. In this migration, there is no direct link between conversations and facts -- that implicit relationship is established through `sender_id` in migration 003.

## How This Fits in the Migration Sequence

Omega uses a sequential migration system. Migrations are numbered and run in order:

| # | File | What It Does |
|---|------|-------------|
| **001** | **`001_init.sql`** | **Creates conversations, messages, and facts tables (this file)** |
| 002 | `002_audit_log.sql` | Adds the `audit_log` table for interaction tracking |
| 003 | `003_memory_enhancement.sql` | Adds summary/status columns to conversations, recreates facts with per-user scoping |

Migration 003 directly modifies the schema established here:
- Adds `summary`, `last_activity`, and `status` columns to `conversations`.
- Drops and recreates the `facts` table with a `sender_id` column and `UNIQUE(sender_id, key)` constraint.

This means the schema you see in a running Omega instance is the result of all three migrations applied in sequence, not just this one.

## How the Gateway Uses These Tables

The gateway's message processing pipeline interacts with these tables at several stages:

1. **Context building** (Stage 5) -- Queries `conversations` and `messages` to fetch recent history for the current user/channel. Also queries `facts` to retrieve known information about the user. The composite indexes on both tables make these lookups efficient.

2. **Message storage** (Stage 7) -- After the provider responds, both the user's input and the assistant's response are inserted into `messages`, linked to the current conversation. The conversation's `updated_at` timestamp is updated.

3. **Background summarization** -- Every 60 seconds, the gateway finds idle conversations and uses the provider to generate a summary and extract facts. The summary is stored in `conversations.summary` (added by migration 003) and extracted facts are stored in the `facts` table.

## Data Types and Conventions

### Text UUIDs for Primary Keys

All primary keys are application-generated UUIDs stored as TEXT. This avoids SQLite's auto-increment behavior and supports deterministic, conflict-free ID generation.

### ISO 8601 Timestamps

All timestamps are stored as ISO 8601 text strings (e.g., `"2025-06-15 14:30:00"`), generated by SQLite's `datetime('now')` function. They are always in UTC.

### Idempotent Statements

Every `CREATE TABLE` and `CREATE INDEX` uses `IF NOT EXISTS`. Running this migration multiple times is safe -- it will not fail or duplicate data.

## Querying the Database Directly

You can inspect the database using the `sqlite3` CLI:

```bash
sqlite3 ~/.omega/data/memory.db
```

**List active conversations:**
```sql
SELECT id, channel, sender_id, started_at, updated_at
FROM conversations
ORDER BY updated_at DESC
LIMIT 10;
```

**Get messages in a conversation:**
```sql
SELECT role, content, timestamp
FROM messages
WHERE conversation_id = 'your-conversation-id'
ORDER BY timestamp ASC;
```

**List all stored facts:**
```sql
SELECT key, value, created_at
FROM facts
ORDER BY updated_at DESC;
```

**Count messages per conversation:**
```sql
SELECT c.id, c.channel, c.sender_id, COUNT(m.id) as message_count
FROM conversations c
LEFT JOIN messages m ON m.conversation_id = c.id
GROUP BY c.id
ORDER BY c.updated_at DESC;
```

## Important Notes for Developers

- **Foreign keys require PRAGMA.** SQLite does not enforce foreign keys by default. The `omega-memory` crate enables enforcement with `PRAGMA foreign_keys = ON;` on each connection. If you query the database with `sqlite3` directly, run this pragma first to get the same behavior.

- **The facts table is replaced by migration 003.** Do not rely on the schema defined here for facts -- the running schema has `sender_id` scoping and a different uniqueness constraint. See migration 003 for the current facts schema.

- **No cascade deletes.** The foreign key constraints do not specify `ON DELETE CASCADE`. Deleting a conversation will fail if it has messages (assuming foreign keys are enforced). Application code must delete messages before deleting their parent conversation.

- **Nullable columns.** Only `metadata_json` on `messages` and `source_message_id` on `facts` are nullable. All other columns require values.
